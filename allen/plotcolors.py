# This draws some graphs of the Allen Developing map colour reverse engineered
# transform. Operates on pydata.h5, generated by plotcolors.m, which was my
# original script to analyse the Allen colours.

# Load h5
import h5py

f = h5py.File ('pydata.h5', 'r')

# Extract the variables
varlist = list(f['pydata']['value'])
blue        = list(f['pydata']['value']['blue']['value'])
ellip_minus = list(f['pydata']['value']['ellip_minus']['value'])
ellip_plus  = list(f['pydata']['value']['ellip_plus']['value'])

ex          = list(f['pydata']['value']['ex']['value'])
fully_transformed = list(f['pydata']['value']['fully_transformed']['value'])
greenred_calc = list(f['pydata']['value']['greenred_calc']['value'])
n_expr      = list(f['pydata']['value']['n_expr']['value'])
ne          = list(f['pydata']['value']['ne']['value'])
tvalues     = list(f['pydata']['value']['tvalues']['value'])
texpr       = list(f['pydata']['value']['texpr']['value'])
tcolr       = list(f['pydata']['value']['tcolr']['value'])

# Make some 3D plots
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import sebcolour
sc = sebcolour.Colour()

# Set plotting defaults
import matplotlib
fs = 14
fnt = {'family' : 'Arial',
       'weight' : 'regular',
       'size'   : fs}
matplotlib.rc('font', **fnt)

# IMPORTANT for svg output of text as things that can be edited in inkscape
plt.rcParams['svg.fonttype'] = 'none'
plt.rcParams['scatter.marker'] = 'o'

fig = plt.figure(figsize=(6,12))

ax1 = fig.add_subplot(311, projection='3d')
# This is the best fit line of the Allen-defined 'expressing' pixels; red-green regressed against blue
ax1.plot(blue[0], greenred_calc[0], greenred_calc[1], color=sc.mediumpurple1)

# Plot expressing as scatter
ne_cols = np.flip(ne,axis=0).T/255.0
ex_cols = np.flip(ex,axis=0).T/255.0

ax1.scatter(ne[0], ne[1], ne[2], s=60, c=ne_cols, edgecolors=sc.sapgreen)
ax1.scatter(ex[0], ex[1], ex[2], s=60, c=ex_cols, edgecolors=sc.purple4)

ax1.set_xlabel('Blue')
ax1.set_ylabel('Green')
ax1.set_zlabel('Red')

ax1.axim = -22
ax1.elev = 39

ax2 = fig.add_subplot(312, projection='3d')
ax2.scatter(fully_transformed[0], fully_transformed[1], fully_transformed[2], s=60, c=ex_cols, edgecolors=sc.purple4)
# Transformed non-expressing
ax2.scatter(n_expr[0], n_expr[1], n_expr[2], s=60, c=ne_cols, edgecolors=sc.sapgreen)
ax2.plot(ellip_plus[0], ellip_plus[1], ellip_plus[2], color=sc.purple4)
ax2.plot(ellip_minus[0], ellip_minus[1], ellip_minus[2], color=sc.purple4)
#ax2.set_ylim([-50, 150])
#ax2.set_zlim([-10, 155])

ax2.set_xlabel('B (inv. expr)')
ax2.set_ylabel('G (variation)')
ax2.set_zlabel('R (variation)')

#ax2.ylim=[-200,50]

ax2.axim = -22
ax2.elev = 39

# Third plot will be signal vs. Blue.
ax3 = fig.add_subplot(313)
tv = np.array(tvalues).T
ex_cols_used = np.flip(tcolr,axis=0).T/255.0
ax3.scatter(texpr[0], tv[0], s=80, c=ex_cols_used, edgecolors=sc.purple4);
ax3.set_xlabel('B (expression)')
ax3.set_ylabel('Expression signal')

# Can't find out how to place a bit of extra margin around the third graph. Will fix in Inkscape.
#plt.subplots_adjust(left=0.2,right=0.8,hspace=0.3)

plt.savefig('allencolors.svg')
plt.show()
