%
% Like plotcolors, but with no plotting. This just generates the
%

% Make sure you loaded data generated by

% The expressing group
b = unique(a, "rows");
% The non-expressing group
o = unique(n, "rows");

len2 = 1000;

lenb = size(b)(1);
rndIDX = randperm(lenb);
% ex is expressing
ex = b(rndIDX(1:len2), :);

leno = size(o)(1);
rndIDX = randperm(leno);
% ne is non-expressing
ne = o(rndIDX(1:len2), :);

% Note: marker face colour is the colour the pixel has on the ISH
% image.
blue = [];
redgreen = [];
for ii = 1:len2
    ex_x = [ex(ii,1)];%b
    ex_y = [ex(ii,2)];%g
    ex_z = [ex(ii,3)];%r
    blue = [blue; ex_x, 1];
    redgreen = [redgreen; ex_y, ex_z];
end

% Linear regression. Regress red/green against blue
thefit = blue\redgreen;
redgreen_calc = (thefit(1,:) .* blue(:,1)) + thefit(2,:);

% Blue input, evenly spaced
%b_in = [0:1:255]';

% Save the translation offset from the fit
trans_offset = thefit(2,:);
trans_offset3d = [0.0, thefit(2,:)];

% Rotation given by thefit(1,:)
x = 1;
yz = thefit(1,:) .* x;
y = thefit(1,1) .* x;
z = thefit(1,2) .* x;

% theta is rotation down to the x-y plane; phi is rotation about
% the z axis.
phi = atan2 (y, x);
theta = atan2 (z, sqrt(x*x + y*y));

% Create rotation matrices
Ay = [cos(theta), 0, sin(theta); ...
      0, 1, 0; ...
      -sin(theta), 0, cos(theta)];

Az = [cos(-phi), -sin(-phi), 0; ...
      sin(-phi), cos(-phi), 0; ...
      0, 0, 1];

% Create original points matrix:
original_points = [blue(:,1), redgreen];
% Create original points with the translation, too:
rgrg_trans = redgreen - trans_offset;
translated_points = [blue(:,1), rgrg_trans];

% Create a single rotation matrix A from Ay and Az
A = Ay * Az;
% These translated, rotated points have 2 rotations applied:
trans_rot_points = (A*translated_points')';

% PCA.
X = trans_rot_points(:,2:3);
% My data are already centered around 0, so no need to subtract the mean:
mu = mean(X);
%Xm = bsxfun(@minus, X, mu)
C = cov(X);
[V,D] = eig(C);

% sort eigenvectors desc
[D, i] = sort(diag(D), 'descend');
V = V(:,i);
% V are eigenvectors, D eigen values - they're like 'variances'

scale = 2.*sqrt(D(1));
pc1_x = mu(1) + scale * V(1,1);
pc1_y = mu(2) + scale * V(2,1);

scale2 = 2.*sqrt(D(2));
pc2_x = mu(1) + scale2 * V(1,2);
pc2_y = mu(2) + scale2 * V(2,2);

% Draw an ellipse.
gamma_rad = atan2(pc1_y, pc1_x);
%gamma = 360 * gamma_rad / (2*pi);

% I've now got a 3rd rotational transformation, so Let's apply this
Ax = [1, 0, 0;...
      0, cos(-gamma_rad), -sin(-gamma_rad); ...
      0, sin(-gamma_rad), cos(-gamma_rad)];

% Note that the output of this script can now be a single rotation
% matrix (A) along with the two axes of the ellipse to form the
% equation to categorize a color as expressing or not expressing.
A = Ax * Ay * Az;
fully_transformed = (A*translated_points')';

ellip_major = 2.*sqrt(D(1));
ellip_minor = 2.*sqrt(D(2));

luminosity_cutoff = 250;
luminosity_factor = -1;

% Process each number through the eqn of the ellipse to get a vlaue
% < or > 1.

%% JSON Results
jsonstr1 = sprintf ('{');
jsonstr2 = sprintf ('"colour_trans" : [ %f, %f, %f ], ', trans_offset3d(1), trans_offset3d(2), trans_offset3d(3));
jsonstr3 = sprintf ('"colour_rot" : [ %f, %f, %f, %f, %f, %f, %f, %f, %f ], ', A(1,1), A(1,2), A(1,3), A(2,1), A(2,2), A(2,3), A(3,1), A(3,2), A(3,3) );
jsonstr4 = sprintf ('"ellip_axes" : [ %f, %f ], ', ellip_major, ellip_minor);
jsonstr5 = sprintf ('"luminosity_factor" : %f, ', luminosity_factor);
jsonstr6 = sprintf ('"luminosity_cutoff" : %f', luminosity_cutoff);
jsonstr7 = sprintf ('}\n');

jsonstr = [jsonstr1 jsonstr2 jsonstr3 jsonstr4 jsonstr5 jsonstr6 jsonstr7];

% Write to file? or best to stdout?
printf (jsonstr)
