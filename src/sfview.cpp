/*
 * A 3D viewer for the data generated by Stalefish
 *
 * This was originally intended as a quick viewer for the data, and is hence written
 * entirely procedurally. As time went by, it turned into a tool that we used to compute
 * common reference frames. The viewing methods used here could potentially be
 * integrated into the main stalefish application, although some of the features here
 * allow for the processing of data from *multiple* stalefish projects.
 *
 * Author: Seb James
 * Date: 2020-2021
 */
#include <morph/Visual.h>
#define BUILD_HDFDATA_WITH_OPENCV 1
#include <morph/HdfData.h>
#include <morph/Vector.h>
#include <morph/tools.h>
#include <iostream>
#include <fstream>
#include <cmath>
#include <array>
#include <morph/PointRowsVisual.h>
#include <morph/PointRowsMeshVisual.h>
#include <morph/ScatterVisual.h>
#include <morph/QuadsVisual.h>
#include <morph/QuadsMeshVisual.h>
#include <morph/RodVisual.h>
#include <morph/TransformMatrix.h>
#include <morph/Matrix33.h>
#include <morph/MathConst.h>
#include <popt.h>

using namespace std;

#ifdef __OSX__
namespace sfview { std::string working_directory = ""; }
#endif

// Derive Visual to add the extra sfview-specific keyhandling callback
class SFVisual : public morph::Visual
{
public:
    SFVisual (int width, int height, const std::string& title,
              const morph::Vector<float, 2> caOffset, const morph::Vector<float> caLength,
              const float caThickness, const float caEm)
        : morph::Visual (width, height, title, caOffset, caLength, caThickness, caEm)
    {
        this->backgroundBlack();
        this->coordArrows->clear();
        this->coordArrows->x_label = "X (Caud)";
        this->coordArrows->y_label = "Y (Lat)";
        this->coordArrows->z_label = "Z (Vent)";
        this->coordArrows->initAxisLabels();
        this->coordArrows->reinit();
    }

    //! Vector of VisualModel IDs for the landmarks. To hide landmarks, hide these.
    std::vector<unsigned int> landmarks;
    //! The 'angle=0' lines - in Jet colours
    std::vector<unsigned int> angle_centres;
    //! The axis (or axes) from 'axis marks'
    std::vector<unsigned int> axes;
    //! The 3D surfaces
    std::vector<unsigned int> surfaces_3d;
    //! 2D surfaces
    std::vector<unsigned int> surfaces_2d;

protected:
    //! Act on keys and toggle 'hidden' for the relevant VisualModels
    virtual void key_callback_extra (GLFWwindow* window, int key, int scancode, int action, int mods)
    {
        // Landmarks
        if (key == GLFW_KEY_F && action == GLFW_PRESS) {
            for (auto id : this->landmarks) { this->vm[id]->toggleHide(); }
        }
        // Angle markers
        if (key == GLFW_KEY_G && action == GLFW_PRESS) {
            for (auto id : this->angle_centres) { this->vm[id]->toggleHide(); }
        }
        // axes
        if (key == GLFW_KEY_D && action == GLFW_PRESS) {
            for (auto id : this->axes) { this->vm[id]->toggleHide(); }
        }
        // 2D map
        if (key == GLFW_KEY_J && action == GLFW_PRESS) {
            for (auto id : this->surfaces_2d) { this->vm[id]->toggleHide(); }
        }
        // 3D map
        if (key == GLFW_KEY_K && action == GLFW_PRESS) {
            for (auto id : this->surfaces_3d) { this->vm[id]->toggleHide(); }
        }

        // Additional help
        if (key == GLFW_KEY_H && action == GLFW_PRESS) {
            std::cout << "sfview help:\n";
            std::cout << "f: toggle (show/hide) landmarks\n";
            std::cout << "g: toggle zero angle marks\n";
            std::cout << "d: toggle user-defined brain axis\n";
            std::cout << "j: toggle 2D brain map\n";
            std::cout << "k: toggle 3D brain surface\n";
        }
    }
};

// Global colour ordering, used for surfaces and global landmarks
// 0 red .2 yellow .3 green .4 cyan green .5 cyan .6 blue .7 blue .8 purple .9 red
vector<float> sfview_hues = {0.0f, 0.7f, 0.8f, 0.1f, 0.5f, 0.6f, 0.1f, 0.8f};
// Return an application-common hue matching the index idx. Used for surface colours and
// global landmarks.
float get_sfview_hue (unsigned int idx)
{
    float hue = 0.0f;
    if (idx < sfview_hues.size()) {
        hue = sfview_hues[idx];
    } else {
        hue = 0.8f;
    }
    return hue;
}

//! libpopt features - the features that are available to change on the command line.
struct CmdOptions
{
    //! If true, then autoscale the signal for each slice
    int scale_perslice;
    //! If true, then use auto align, even if landmark alignment data is present
    int use_autoalign;
    //! If true, plot ribbons for 3D instead of the smooth surface map. Useful for debugging
    int show_ribbons;
    //! If true, plot the meshy version of the surface, with no colour
    int show_mesh;
    //! Show examle data
    int show_example;
    //! If true, use ambient/diffuse lighting
    int lighting;
    //! If true, use white background
    int whitebg;
    //! If true, hide colour map and plot in white.
    int hide_colour;
    //! Show landmarks from first model
    int show_landmarks;
    //! Show landmarks from all models
    int show_landmarks_all;
    //! Takes the index of the flattened map to show
    int show_flattened;
    //! flattened_type could be 0. aligned linear distance, starting from angle 0 1. linear distance, centered, 2. angle of thing about 0.
    int flattened_type;
    //! Apply Linear Transforms based on global landmarks. 2: 2D 3: 3D. Let there be a
    //! matrix M, which can be applied to a vector A to transform it into a vector D.
    //! D = M * A => M = D * inv(A).
    int linear_transforms;
    //! If >0, then show slice thicknesses, rather than drawing boxes from current x position to the next slice's x position.
    int show_slice_thickness;
    //! Temporary datafile, for adding to datafiles.
    char* datafile;
    //! extents string
    char* extents_str;
    //! The extents extracted from extents_str
    morph::Vector<float, 4> extents;
    //! The h5 files to visualize
    std::vector<string> datafiles;
};

//! Initialise a CmdOptions object
void zeroCmdOptions (CmdOptions* copts)
{
    copts->scale_perslice = 0;
    copts->use_autoalign = 0;
    copts->show_ribbons = 0;
    copts->show_mesh = 0;
    copts->show_example = 0;
    copts->lighting = 0;
    copts->whitebg = 0;
    copts->hide_colour = 0; // Default to showing colour
    copts->show_landmarks = 1;
    copts->show_landmarks_all = 0;
    copts->show_flattened = 0;
    copts->flattened_type = 0;
    copts->linear_transforms = 0;
    copts->show_slice_thickness = 0;
    copts->datafile = (char*)0;
    copts->extents_str = (char*)0;
    copts->extents = {0.0f, 0.0f, 0.0f, 0.0f};
    copts->datafiles.clear();
}

//! cmdOptions is global, allowing callbacks to access this easily.
struct CmdOptions cmdOptions;

/*!
 * This callback is used when there's a -f option, to allow me to
 * collect multiple files for visualization (e.g. to vis. multiple layers)
 *
 * e.g. viewer -f /path/to/ctx_superficial.h5 -f /path/to/ctx_mid.h5
 */
void popt_option_callback (poptContext con,
                           enum poptCallbackReason reason,
                           const struct poptOption * opt,
                           const char * arg,
                           void * data)
{
    switch(reason) {
    case POPT_CALLBACK_REASON_PRE: { break; } // Doesn't occur
    case POPT_CALLBACK_REASON_POST: { break; } // Ignore
    case POPT_CALLBACK_REASON_OPTION:
    {
        // Test shortName. This means we could respond to other "multiple options"
        if (opt->shortName == 'f') {
            cmdOptions.datafiles.push_back (cmdOptions.datafile);
        } else if (opt->shortName == 'x') {
            // Process cmdOptions.extents_str
            std::string ex(cmdOptions.extents_str);
            std::vector<std::string> exn = morph::Tools::stringToVector (ex, ",");
            if (exn.size() == 4) {
                for (size_t i = 0; i < 4; ++i) {
                    std::stringstream ss;
                    float f = 0.0f;
                    ss << exn[i];
                    ss >> f;
                    cmdOptions.extents[i] = f;
                }
            } else {
                throw std::runtime_error ("extents string is not well formed (give 4 comma-separated numbers)");
            }
        }
        break;
    }
    }
}

bool check_lmalignment (morph::HdfData& d)
{
    int nf = 0;
    d.read_val ("/nframes", nf);
    bool lmalignComputed = false;
    // If ANY frame has lmalign computed we mark lmalignComputed. Similar for autoalignComputed
    for (int i = 1; i <= nf; ++i) {
        stringstream ss;
        ss << "/Frame";
        ss.width(3);
        ss.fill('0');
        ss << i;
        bool lac = false;
        string str = ss.str()+"/lmalign/computed";
        d.read_val (str.c_str(), lac);
        if (lac == true) { lmalignComputed = true; }
    }
    return lmalignComputed;
}

bool check_autoalignment (morph::HdfData& d)
{
    int nf = 0;
    d.read_val ("/nframes", nf);
    bool autoalignComputed = false;
    for (int i = 1; i <= nf; ++i) {
        stringstream ss;
        ss << "/Frame";
        ss.width(3);
        ss.fill('0');
        ss << i;
        bool lac = false;
        string str = ss.str()+"/autoalign/computed";
        d.read_val (str.c_str(), lac);
        if (lac == true) { autoalignComputed = true; }
    }
    return autoalignComputed;
}

unsigned int countGlobalLandmarks (const string& datafile)
{
    morph::HdfData d(datafile, morph::FileAccess::ReadOnly);
    std::vector<std::pair<unsigned int, unsigned int>> glm_table;
    d.read_contained_vals ("/global_landmarks", glm_table);
    return glm_table.size();
}

morph::TransformMatrix<float> readGlobalMatrix (const std::string& datafile)
{
    // D = MA => M = D inv(A)
    morph::TransformMatrix<float> A;
    std::cout << "Opening " << datafile << std::endl;
    morph::HdfData d(datafile, morph::FileAccess::ReadOnly);
    int nf = 0;
    d.read_val ("/nframes", nf);

    // Check first frame for alignments
    bool lmalignComputed = false;
    d.read_val ("/Frame001/lmalign/computed", lmalignComputed);
    bool autoalignComputed = false;
    d.read_val ("/Frame001/autoalign/computed", autoalignComputed);
    string frameName("");

    // Get global landmarks
    std::vector<std::pair<unsigned int, unsigned int>> glm_table;
    d.read_contained_vals ("/global_landmarks", glm_table);
    vector<array<float, 3>> allGLM;
    for (auto glmt : glm_table) {
        //std::cout << "Frame: " << glmt.first << ", index: " << glmt.second << std::endl;
        stringstream ss;
        ss << "/Frame";
        ss.width(3);
        ss.fill('0');
        if (lmalignComputed == true) {
            ss << glmt.first << "/lmalign/global_landmarks";
        } else {
            ss << glmt.first << "/autoalign/global_landmarks";
        }
        frameName = ss.str();
        // FIXME: I suspect an issue with the order of the global landmarks.
        vector<array<float, 3>> GLM;
        std::cout << "Reading global landmark in " << frameName << std::endl;
        d.read_contained_vals(frameName.c_str(), GLM);
        std::cout << "The GLM has size " << GLM.size() << std::endl;
        array<float, 3> th = GLM[glmt.second];
        std::cout << "About to push_back GLM[" << glmt.second << "] (" <<  th[0] << "," << th[1] << "," << th[2] << ")\n";
        allGLM.push_back (GLM[glmt.second]);
    }
    if (allGLM.size() < 4) {
        std::cerr << "Need at least 4 global landmarks.\n";
        return A;
    }

    // Can loop through first 4 entries in GLM
    for (size_t i = 0; i < 4; ++i) {
        size_t start = i*4;
        for (size_t j = 0; j<3; ++j) {
            A[start+j] = allGLM[i][j];
        }
        A[start+3] = 1;
    }

    return A;
}

//! Compute linear transformations to apply to datafiles
void computeTransforms (const vector<string>& datafiles,
                        vector<morph::TransformMatrix<float>>& M,
                        const CmdOptions& co)
{
    if (datafiles.size() < 2) {
        // nothing to do though ensure M[0] contains identity, if necessary
        if (datafiles.size()==1 && M.size()==1) { M[0].setToIdentity(); }
        return;
    }

    if (datafiles.size() != M.size()) {
        std::cerr << "WARNING: datafiles and M have to have the same size. Returning.\n";
        return;
    }

    M[0].setToIdentity();

    // now the fun stuff. Get the relevant global landmark vectors
    morph::TransformMatrix<float> D = readGlobalMatrix (datafiles[0]);
    std::cout << "D (destination simplex) matrix, determined from first set of global landmarks:\n" << D << std::endl;

    // Now get 'A' matrices from datafiles[1] and up
    for (size_t di = 1; di < datafiles.size(); ++di) {
        // A holds the positions of the global landmarks
        morph::TransformMatrix<float> A = readGlobalMatrix (datafiles[di]);
        std::cout << "A" << di << " =\n" << A << std::endl;
        morph::TransformMatrix<float> Ainv = A.invert();
        //std::cout << "inv(A" << di << "):\n" << Ainv << std::endl;
        // Can now compute M (named M in my octave code)
        M[di] = D * Ainv;
        //std::cout << "M["<<di<<"]:\n" << M[di] << std::endl;
    }
}

//! Add just the landmarks (and global landmarks) in the datafile
//! M: the transform matrix
int addLandmarks (SFVisual& v, const string& datafile, const CmdOptions& co,
                  const morph::TransformMatrix<float>& M, int number)
{
    std::cout << __FUNCTION__ << " called\n";
    int rtn = 0;

    bool align_lm = co.use_autoalign > 0 ? false : true;

    try {
        morph::Vector<float> offset = { 0.0, 0.0, 0.0 };

        morph::Scale<float> scale;
        scale.setParams (1.0, 0.0);
        float xx = 0.0f;

        vector<morph::Vector<float>> landmarks_autoaligned;
        vector<morph::Vector<float>> landmarks_lmaligned;

        // Global landmarks
        vector<morph::Vector<float>> globlm_autoaligned;
        vector<morph::Vector<float>> globlm_lmaligned;
        vector<float> glm_id;

        vector<float> landmarks_id;

        {
            morph::HdfData d(datafile, morph::FileAccess::ReadOnly);
            int nf = 0;
            d.read_val ("/nframes", nf);

            bool lmalignComputed = check_lmalignment(d);
            //bool autoalignComputed = check_autoalignment(d);

            string frameName("");
            for (int i = 1; i<=nf; ++i) {

                stringstream ss;
                ss << "/Frame";
                ss.width(3);
                ss.fill('0');
                ss << i;
                frameName = ss.str();

                // x position comes from FrameNNN/class/layer_x
                string str = frameName+"/class/layer_x";
                d.read_val (str.c_str(), xx);

                // Landmarks
                vector<array<float, 3>> LM_autoaligned;
                vector<array<float, 3>> LM_lmaligned;
                str = frameName+"/autoalign/landmarks";
                d.read_contained_vals (str.c_str(), LM_autoaligned);
                str = frameName+"/lmalign/landmarks";
                d.read_contained_vals (str.c_str(), LM_lmaligned);
                size_t lmcount = 0;
                float lmid = 0.0f;
                float lmidmax = (float)LM_autoaligned.size();
                for (auto lm : LM_autoaligned) {
                    // TransformMatrix can post multiply by a 3-vector, returning a 4-vector:
                    morph::Vector<float, 4> _lm = M * morph::Vector<float, 3>({lm[0],lm[1],lm[2]});
                    landmarks_autoaligned.push_back ({_lm[0], _lm[1], _lm[2]});
                    lmid = (float)lmcount++ / lmidmax;

                    landmarks_id.push_back (lmid);
                }
                //! convert from vector<array> to vector<Vector> transforming as we go
                for (auto lm : LM_lmaligned) {
                    morph::Vector<float, 4> _lm = M * morph::Vector<float, 3>({lm[0],lm[1],lm[2]});
                    landmarks_lmaligned.push_back ({_lm[0], _lm[1], _lm[2]});
                }
            }

            // Now process global landmarks
            std::vector<std::pair<unsigned int, unsigned int>> glm_table;
            d.read_contained_vals ("/global_landmarks", glm_table);
            float glmcount = 1.0f;
            for (auto glm : glm_table) {
                std::cout << "Frame: " << glm.first << ", index: " << glm.second << std::endl;
                stringstream ss;
                ss << "/Frame";
                ss.width(3);
                ss.fill('0');
                if (lmalignComputed == true && align_lm == true) {
                    ss << glm.first << "/lmalign/global_landmarks";
                } else {
                    ss << glm.first << "/autoalign/global_landmarks";
                }
                frameName = ss.str();
                vector<array<float, 3>> GLM;
                //std::cout << "Reading global landmark in " << frameName << std::endl;
                d.read_contained_vals (frameName.c_str(), GLM);
                //std::cout << "GLM size: " << GLM.size() << std::endl;
                for (auto glm : GLM) {
                    morph::Vector<float, 4> _glm = M * morph::Vector<float, 3>({glm[0],glm[1],glm[2]});
                    if (lmalignComputed == true && align_lm == true) {
                        globlm_lmaligned.push_back ({_glm[0], _glm[1], _glm[2]});
                    } else {
                        globlm_autoaligned.push_back ({_glm[0], _glm[1], _glm[2]});
                    }
                    glm_id.push_back (glmcount);
                    glmcount -= 0.2f;
                    std::cout << "Added global landmark sphere, glm_id = " << glm_id.back() << std::endl;
                }
            }

            unsigned int visId = 0;

            offset[0]=0.0;

            // Show landmark aligned for preference:
            if (lmalignComputed == true && align_lm == true) {
                // Show the landmarks with a ScatterVisual
                auto sv1 = new morph::ScatterVisual<float> (v.shaderprog, offset);
                sv1->setDataCoords (&landmarks_lmaligned);
                sv1->setScalarData (&landmarks_id);
                sv1->radiusFixed = 0.07f;
                sv1->colourScale = scale;
                sv1->cm.setType (morph::ColourMapType::Plasma);
                sv1->finalize();
                visId = v.addVisualModel (sv1);
                v.landmarks.push_back (visId);
#ifdef __DEBUG
                std::cout << "Showing LM aligned global landmarks...\n";
                for (auto ii : globlm_lmaligned) { std::cout << ii << std::endl; }
                std::cout << "glm_id:\n";
                for (auto ii : glm_id) { std::cout << ii << std::endl; }
#endif
                if (!globlm_lmaligned.empty()) {
                    auto sv2 = new morph::ScatterVisual<float> (v.shaderprog, offset);
                    sv2->setDataCoords (&globlm_lmaligned);
                    sv2->setScalarData (&glm_id);
                    sv2->radiusFixed = 0.1f;
                    sv2->colourScale = scale;
                    sv2->cm.setType (morph::ColourMapType::Jet);
                    sv2->finalize();
                    visId = v.addVisualModel (sv2);
                    v.landmarks.push_back (visId);
                }
            } else {
                morph::ScatterVisual<float>* lmv = new morph::ScatterVisual<float> (v.shaderprog, offset);
                lmv->dataCoords = &landmarks_autoaligned;
                lmv->scalarData = &landmarks_id;
                lmv->radiusFixed = 0.07f;
                lmv->colourScale = scale;
                lmv->cm.setType (morph::ColourMapType::Plasma);
                lmv->finalize();
                visId = v.addVisualModel (lmv);

                v.landmarks.push_back (visId);

                std::cout << "Showing auto aligned global landmarks number " << number << "...\n";
                morph::ScatterVisual<float>* glmv = new morph::ScatterVisual<float> (v.shaderprog, offset);
                glmv->dataCoords = &globlm_autoaligned;
                glmv->scalarData = &glm_id; // Not ID for the number, instead, pass in index.
                glmv->radiusFixed = 0.05f;
                glmv->colourScale.compute_autoscale (0, 1);
                float hue = get_sfview_hue (number-1);
                //glmv->cm.setType (morph::ColourMapType::Fixed);
                //glmv->cm.setHSV (hue, 1.0f, 1.0f);
                glmv->cm.setType (morph::ColourMapType::Monochrome);
                glmv->cm.setHue (hue);
                glmv->finalize();
                visId = v.addVisualModel (glmv);

                v.landmarks.push_back (visId);
            }
        }
    } catch (const exception& e) {
        cerr << "Caught exception: " << e.what() << endl;
        rtn = -1;
    }

    return rtn;
}

//! Add a 3D visual model for an expression surface, created from the file datafile, to the scene v
int addVisMod (SFVisual& v, const string& datafile, const CmdOptions& co, const float hue,
               morph::TransformMatrix<float>& M)
{
    std::cout << __FUNCTION__ << " called with M=\n" << M << std::endl;
    int rtn = 0;

    bool autoscale_per_slice = co.scale_perslice > 0 ? true : false;
    bool align_lm = co.use_autoalign > 0 ? false : true;
    bool showribbons = co.show_ribbons > 0 ? true : false;
    bool showmesh = co.show_mesh > 0 ? true : false;
    bool showcolour = co.hide_colour > 0 ? false : true;
    float colour_sat = showcolour ? 1.0f : 0.0f;
    std::cout << "colour_sat = " << colour_sat << std::endl;
    morph::ColourMapType cmt = morph::ColourMapType::Monochrome;
    if (showcolour == false) { cmt = morph::ColourMapType::Fixed; }

    try {
        morph::Vector<float> offset = { 0.0, 0.0, 0.0 };

        morph::Scale<float> scale;
        scale.setParams (1.0, 0.0);

        float thickness = 0.0f;
        float xx = 0.0f;

        vector<array<float, 12>> quads_autoaligned; // Get from HDF5
        vector<array<float, 12>> quads_lmaligned;
        std::cout << "quads_lmaligned.size() = " << quads_lmaligned.size() << std::endl;
        vector<array<float, 12>> quads_scaled;
        vector<morph::Vector<float>> points_autoaligned; // Centres of boxes; for smooth surface (points rows)
        vector<morph::Vector<float>> points_lmaligned; // Centres of boxes; for smooth surface (points rows)
        vector<morph::Vector<float>> points_scaled; // Centres of boxes; for smooth surface (points rows)
        vector<float> means;

        // For the 'centres' These are the locations, around the curve that are an equal
        // angle about the user-defined brain axis.
        vector<morph::Vector<float>> centres_lmaligned;
        vector<morph::Vector<float>> centres_autoaligned;
        // Alignment landmarks
        vector<morph::Vector<float>> AM_origins_lmaligned;
        vector<morph::Vector<float>> AM_origins_autoaligned;
        vector<float> centres_id;

        {
            cout << "addVisMod: Opening H5 file " << datafile << endl;
            morph::HdfData d(datafile, morph::FileAccess::ReadOnly);
            d.read_error_action = morph::ReadErrorAction::Exception;
            int nf = 0;
            d.read_val ("/nframes", nf);

            string frameName("");

            // Check first frame for alignments
            bool lmalignComputed = check_lmalignment(d);

            for (int i = 1; i<=nf; ++i) {

                stringstream ss;
                ss << "/Frame";
                ss.width(3);
                ss.fill('0');
                ss << i;
                frameName = ss.str();

                // x position comes from FrameNNN/class/layer_x
                string str = frameName+"/class/layer_x";
                d.read_val (str.c_str(), xx);
                str = frameName+"/class/thickness";
                d.read_val (str.c_str(), thickness);

                // Centres. Get the index into the fitted_lmaligned, to get y/z coordinates of centre locations
                str = frameName+"/lmalign/centre_box_index";
                int clm_idx = 0;
                d.read_val (str.c_str(), clm_idx);

                str = frameName+"/autoalign/centre_box_index";
                int caa_idx = 0;
                d.read_val (str.c_str(), caa_idx);

                std::vector<cv::Point2d> fitted_lmaligned;
                str = frameName+"/lmalign/fitted";
                d.read_contained_vals (str.c_str(), fitted_lmaligned);

                std::vector<cv::Point2d> fitted_autoaligned;
                str = frameName+"/autoalign/fitted";
                d.read_contained_vals (str.c_str(), fitted_autoaligned);

                morph::Vector<float> cp;
                cp[0] = xx;
                cp[1] = fitted_lmaligned[clm_idx].x;
                cp[2] = fitted_lmaligned[clm_idx].y;
                morph::Vector<float, 4> _cp = M * cp;
                centres_lmaligned.push_back ({_cp[0], _cp[1], _cp[2]});

                cp[1] = fitted_autoaligned[caa_idx].x;
                cp[2] = fitted_autoaligned[caa_idx].y;
                //std::cout << "Applying M to centre location\n";
                _cp = M * cp;
                centres_autoaligned.push_back ({_cp[0], _cp[1], _cp[2]});
                centres_id.push_back (0.1f*(float)i);

                // axis alignment marks are optional, and the data may not exist in the h5 file.
                try {
                    std::vector<cv::Point2d> AM_lmaligned;
                    str = frameName+"/lmalign/alignmark_origins";
                    d.read_contained_vals (str.c_str(), AM_lmaligned);
                    cp[1] = AM_lmaligned[0].x;
                    cp[2] = AM_lmaligned[0].y;
                    //std::cout << "Applying M to alignment mark location (lmaligned)\n";
                    _cp = M * cp;
                    //std::cout << "Got LM alignmark at " << _cp[0] << "," << _cp[1] << "," << _cp[2] << ".\n";
                    AM_origins_lmaligned.push_back ({_cp[0], _cp[1], _cp[2]});
                } catch (const exception& ee) {
                    // Ignore missing AM_origins
                    //std::cout << "Missing alignmark_origins: " << ee.what() << std::endl;
                }

                // axis alignment marks are optional, and the data may not exist in the h5 file.
                try {
                    std::vector<cv::Point2d> AM_autoaligned;
                    str = frameName+"/autoalign/alignmark_origins";
                    d.read_contained_vals (str.c_str(), AM_autoaligned);
                    cp[1] = AM_autoaligned[0].x;
                    cp[2] = AM_autoaligned[0].y;
                    //std::cout << "Applying M to alignment mark location (autoaligned)\n";
                    _cp = M * cp;
                    //std::cout << "Got Auto alignmark at " << _cp[0] << "," << _cp[1] << "," << _cp[2] << ".\n";
                    AM_origins_autoaligned.push_back ({_cp[0], _cp[1], _cp[2]});
                } catch (const exception& ee) {
                    // Ignore missing AM_origins
                    //std::cout << "Missing alignmark_origins: " << ee.what() << std::endl;
                }

                // frameQuads are for the ribbon visualization
                vector<array<float, 12>> frameQuads_scaled;
                vector<array<float, 12>> frameQuads_lmaligned;
                vector<array<float, 12>> frameQuads_autoaligned;

                // framePoints (the centroids of the quads) are for the surface visualization
                vector<morph::Vector<float>> framePoints_autoaligned;
                vector<morph::Vector<float>> framePoints_lmaligned;
                vector<morph::Vector<float>> framePoints_scaled;

                // Read quads and data for each frame and add to an overall pair of vectors...
                str = frameName+"/autoalign/sboxes";
                d.read_contained_vals (str.c_str(), frameQuads_autoaligned);
                str = frameName+"/lmalign/sboxes";
                d.read_contained_vals (str.c_str(), frameQuads_lmaligned);
                // Un-transformed:
                str = frameName+"/scaled/sboxes";
                d.read_contained_vals (str.c_str(), frameQuads_scaled);

                // Transform frameQuads here (then don't need to transform framePoints, below)
                for (auto& fq : frameQuads_lmaligned) {
                    morph::TransformMatrix<float> pt;
                    pt[0] = fq[0];
                    pt[1] = fq[1];
                    pt[2] = fq[2];
                    pt[3] = 1.0f;

                    pt[4] = fq[3];
                    pt[5] = fq[4];
                    pt[6] = fq[5];
                    pt[7] = 1.0f;

                    pt[8] = fq[6];
                    pt[9] = fq[7];
                    pt[10] = fq[8];
                    pt[11] = 1.0f;

                    pt[12] = fq[9];
                    pt[13] = fq[10];
                    pt[14] = fq[11];
                    pt[15] = 1.0f;

                    ///std::cout << "Applying M to a quad in frameQuads_lmaligned\n";
                    //std::cout << M << "\n*\n" << pt << "\n=\n";
                    morph::TransformMatrix<float> pt_trans = M * pt;
                    //std::cout << pt_trans << "\n--------------\n";
                    fq[0] = pt_trans[0];
                    fq[1] = pt_trans[1];
                    fq[2] = pt_trans[2];

                    fq[3] = pt_trans[4];
                    fq[4] = pt_trans[5];
                    fq[5] = pt_trans[6];

                    fq[6] = pt_trans[8];
                    fq[7] = pt_trans[9];
                    fq[8] = pt_trans[10];

                    fq[9] = pt_trans[12];
                    fq[10] = pt_trans[13];
                    fq[11] = pt_trans[14];

                    //std::cout << "fq[0] = " << fq[0] << ", and pt[0] = " << pt[0] << " (same?)\n";
                }
                for (auto fq : frameQuads_lmaligned) {
                    // Push back just one corner of each frameQuad onto framePoints
                    framePoints_lmaligned.push_back ({fq[0], fq[1], fq[2]});
                }

                for (auto& fq : frameQuads_autoaligned) {

                    morph::TransformMatrix<float> pt;
                    pt[0] = fq[0];
                    pt[1] = fq[1];
                    pt[2] = fq[2];
                    pt[3] = 1.0f;

                    pt[4] = fq[3];
                    pt[5] = fq[4];
                    pt[6] = fq[5];
                    pt[7] = 1.0f;

                    pt[8] = fq[6];
                    pt[9] = fq[7];
                    pt[10] = fq[8];
                    pt[11] = 1.0f;

                    pt[12] = fq[9];
                    pt[13] = fq[10];
                    pt[14] = fq[11];
                    pt[15] = 1.0f;

                    ///std::cout << "Applying M to a quad in frameQuads_autoaligned\n";
                    ///std::cout << "Transformed point (" << fq[0] << "," << fq[1] << "," << fq[2] << ") to ";
                    //std::cout << M << "\n*\n" << pt << "\n=\n";
                    morph::TransformMatrix<float> pt_trans = M * pt;
                    //std::cout << pt_trans << "\n--------------\n";
                    fq[0] = pt_trans[0];
                    fq[1] = pt_trans[1];
                    fq[2] = pt_trans[2];

                    fq[3] = pt_trans[4];
                    fq[4] = pt_trans[5];
                    fq[5] = pt_trans[6];

                    fq[6] = pt_trans[8];
                    fq[7] = pt_trans[9];
                    fq[8] = pt_trans[10];

                    fq[9] = pt_trans[12];
                    fq[10] = pt_trans[13];
                    fq[11] = pt_trans[14];
                    ///std::cout << " point (" << fq[0] << "," << fq[1] << "," << fq[2] << ")\n";

                    // FIXME: Use centre of box, or even each end of box, or something
                    framePoints_autoaligned.push_back ({pt_trans[0], pt_trans[1], pt_trans[2]});
                }

                for (auto fq : frameQuads_scaled) {
                    morph::Vector<float> pt = {fq[0],fq[1],fq[2]};
                    morph::Vector<float, 4> _pt = M * pt;
                    framePoints_scaled.push_back ({_pt[0], _pt[1], _pt[2]});
                }

                vector<double> frameMeans;
                try {
                    if (autoscale_per_slice) {
                        // Use the auto-scaled version of the means, with each slice autoscaled to [0,1]
                        str = frameName+"/signal/postproc/boxes/means_autoscaled";
                        d.read_contained_vals (str.c_str(), frameMeans);
                    } else {
                        // Use the raw means and autoscale them as an entire group
                        str = frameName+"/signal/postproc/boxes/means";
                        d.read_contained_vals (str.c_str(), frameMeans);
                        // The morph::Scale object scale with autoscale the who
                        // thing. NB: This is used only for the colour scaling in the 3D
                        // visualization
                        scale.do_autoscale = true;
                    }
                } catch (const exception& ee) {
                    // Perhaps this slice has not curve on it. Handle this by leaving frameMeans empty and continuing
                    std::cout << "No curve?\n";
                    continue;
                }
                // Gah, convert frameMeans to float (there's a better way to do this)
                vector<float> frameMeansF;
                for (unsigned int j = 0; j < frameMeans.size(); ++j) {
                    frameMeansF.push_back (static_cast<float>(frameMeans[j]));
                }

                // Append the frameQuads for the curve on one slice onto the container that has the quads for the *entire slice set*.
                quads_autoaligned.insert (quads_autoaligned.end(), frameQuads_autoaligned.begin(), frameQuads_autoaligned.end());
                quads_lmaligned.insert (quads_lmaligned.end(), frameQuads_lmaligned.begin(), frameQuads_lmaligned.end());
                quads_scaled.insert (quads_scaled.end(), frameQuads_scaled.begin(), frameQuads_scaled.end());
                means.insert (means.end(), frameMeansF.begin(), frameMeansF.end());

                // Similar, for points
                points_lmaligned.insert (points_lmaligned.end(), framePoints_lmaligned.begin(), framePoints_lmaligned.end());
                points_autoaligned.insert (points_autoaligned.end(), framePoints_autoaligned.begin(), framePoints_autoaligned.end());
                points_scaled.insert (points_scaled.end(), framePoints_scaled.begin(), framePoints_scaled.end());
            }
            unsigned int visId = 0;

            offset[0]=0.0;

            // Show landmark aligned for preference:
            if (lmalignComputed == true && align_lm == true) {
                std::cout << "Landmark aligned.\n";
                if (showribbons) {
                    std::cout << "Show ribbons.\n";
                    if (showmesh) {
                        std::cout << "Show mesh. Adding QuadsMeshVisual with hue=" << hue << std::endl;
                        visId = v.addVisualModel (new morph::QuadsMeshVisual<float> (v.shaderprog,
                                                                                     &quads_lmaligned, offset,
                                                                                     &means, scale,
                                                                                     cmt, hue, colour_sat, 0.005f));
                    } else {
                        std::cout << "NO mesh. Adding QuadsVisual with hue=" << hue << std::endl;
                        visId = v.addVisualModel (new morph::QuadsVisual<float> (v.shaderprog,
                                                                                 &quads_lmaligned, offset,
                                                                                 &means, scale,
                                                                                 cmt, hue));
                    }
                } else {
                    // Want to be able to pass colour==off to these. That means ability to pass sat as well as hue.
                    if (showmesh) {
                        std::cout << "Adding pointRowsMeshVisual with hue=" << hue << std::endl;
                        // hue: 1/6 for yellow. 130/360 for a green. 0 for read
                        visId = v.addVisualModel (new morph::PointRowsMeshVisual<float> (v.shaderprog,
                                                                                         &points_lmaligned, offset,
                                                                                         &means, scale,
                                                                                         cmt, hue, colour_sat, 0.9f, 0.005f,
                                                                                         cmt, (0.0/360.0f), 1.0f, 1.0f, 0.015f));
                    } else {
                        std::cout << "Adding PointRowsVisual with hue=" << hue << std::endl;
                        visId = v.addVisualModel (new morph::PointRowsVisual<float> (v.shaderprog,
                                                                                     &points_lmaligned, offset,
                                                                                     &means, scale,
                                                                                     cmt, hue));
                    }
                }
                v.surfaces_3d.push_back (visId);

                auto sv1 = new morph::ScatterVisual<float> (v.shaderprog, offset);
                sv1->setDataCoords (&centres_lmaligned);
                sv1->setScalarData (&centres_id);
                sv1->radiusFixed = 0.03f;
                sv1->colourScale = scale;
                sv1->cm.setType (morph::ColourMapType::Jet);
                sv1->finalize();
                visId = v.addVisualModel (sv1);

                v.angle_centres.push_back (visId);

                if (!AM_origins_lmaligned.empty()) {
                    size_t amo_last = AM_origins_lmaligned.size()-1;
                    std::array<float, 3> rcol = {1.0f,1.0f,1.0f};
                    visId = v.addVisualModel (new morph::RodVisual (v.shaderprog, offset,
                                                                    AM_origins_lmaligned[0], AM_origins_lmaligned[amo_last],
                                                                    0.05f, rcol));
                    v.axes.push_back (visId);
                }

            } else {
                std::cout << "NOT landmark aligned (thus auto-aligned)\n";
                if (showribbons) {
                    std::cout << "Show ribbons.\n";
                    if (showmesh) {
                        std::cout << "Show mesh. Adding QuadsMeshVisual with hue=" << hue << std::endl;
                        visId = v.addVisualModel (new morph::QuadsMeshVisual<float> (v.shaderprog,
                                                                                     &quads_autoaligned, offset,
                                                                                     &means, scale,
                                                                                     cmt, hue, colour_sat, 0.005f));
                    } else {
                        std::cout << "NO mesh. Adding QuadsVisual with hue=" << hue << std::endl;
                        visId = v.addVisualModel (new morph::QuadsVisual<float> (v.shaderprog,
                                                                                 &quads_autoaligned, offset,
                                                                                 &means, scale,
                                                                                 cmt, hue));
                    }
                } else {
                    std::cout << "NON ribbons.\n";
                    if (showmesh) {
                        std::cout << "Show mesh. Adding pointRowsMeshVisual with hue=" << hue << std::endl;
                        // hue: 1/6 for yellow. 130/360 for a green. 0 for read
                        visId = v.addVisualModel (new morph::PointRowsMeshVisual<float> (v.shaderprog,
                                                                                         &points_autoaligned, offset,
                                                                                         &means, scale,
                                                                                         cmt, hue, colour_sat, 0.9f, 0.005f,
                                                                                         cmt, (0.0/360.0f), 1.0f, 1.0f, 0.015f));
                    } else {
                        std::cout << "NO mesh. Adding PointRowsVisual\n";
                        std::cout << "points_autoaligned contains " << points_autoaligned.size() << " points\n";
                        visId = v.addVisualModel (new morph::PointRowsVisual<float> (v.shaderprog,
                                                                                     &points_autoaligned, offset,
                                                                                     &means, scale,
                                                                                     cmt, hue));
                    }
                }
                v.surfaces_3d.push_back (visId);

                std::cout << "ScatterVisual of centres_autoaligned\n";
                auto sv1 = new morph::ScatterVisual<float> (v.shaderprog, offset);
                sv1->setDataCoords (&centres_autoaligned);
                sv1->setScalarData (&centres_id);
                sv1->radiusFixed = 0.03f;
                sv1->colourScale = scale;
                sv1->cm.setType (morph::ColourMapType::Jet);
                sv1->finalize();
                visId = v.addVisualModel (sv1);
                v.angle_centres.push_back (visId);

                if (!AM_origins_autoaligned.empty()) {
                    size_t amo_last = AM_origins_autoaligned.size()-1;
                    std::array<float, 3> rcol = {1.0f,1.0f,1.0f};
                    visId = v.addVisualModel (new morph::RodVisual (v.shaderprog, offset,
                                                                    AM_origins_autoaligned[0], AM_origins_autoaligned[amo_last],
                                                                    0.05f, rcol));
                    v.axes.push_back (visId);
                }
            }
        }
    } catch (const exception& e) {
        cerr << "addVisMod: Caught exception: " << e.what() << endl;
        rtn = -1;
    }

    return rtn;
}

//! Read 3 global landmark positions and place them in a 3x3 matrix.
morph::Matrix33<float> readGlobalPositions (const std::string& datafile,
                                            std::array<unsigned int, 3>& frame_indices)
{
    morph::Matrix33<float> P;
    morph::HdfData d(datafile, morph::FileAccess::ReadOnly);

    bool lmalignComputed = check_lmalignment(d);
    //bool autoalignComputed = check_autoalignment(d);
    string frameName("");

    // Get global landmarks
    std::vector<std::pair<unsigned int, unsigned int>> glm_table;
    d.read_contained_vals ("/global_landmarks", glm_table);
    vector<array<float, 3>> allGLM;
    size_t i = 0;
    for (auto glmt : glm_table) {
        std::cout << "Frame: " << glmt.first << ", index: " << glmt.second << std::endl;
        frame_indices[i++] = glmt.first;
        stringstream ss;
        ss << "/Frame";
        ss.width(3);
        ss.fill('0');
        if (lmalignComputed == true) {
            ss << glmt.first << "/lmalign/global_landmarks";
        } else {
            ss << glmt.first << "/autoalign/global_landmarks";
        }
        frameName = ss.str();
        vector<array<float, 3>> GLM;
        std::cout << "Reading global landmark in " << frameName << std::endl;
        d.read_contained_vals(frameName.c_str(), GLM);
        allGLM.push_back (GLM[glmt.second]);
    }
    if (allGLM.size() < 3) {
        std::cerr << "Need at least 3 global landmarks.\n";
        return P;
    }

    // Can loop through first 3 entries in GLM
    for (size_t i = 0; i < 3; ++i) {
        size_t start = i*3;
        for (size_t j = 0; j<3; ++j) {
            P[start+j] = allGLM[i][j];
        }
    }

    return P;
}

//! Take 3 coordinates in the 3x3 matrix A3D ('A in 3 dimensions') and convert these
//! into 2D coordinates in the flattened brain plane. Return a 3x3 matrix containing
//! these 2D coords in a form suitable for transformation by a 3x3 transform matrix.
//! datafile: which h5 file are we working with?  co: The command options.  A3D: The
//! global landmark Positions as a 3x3 matrix frame_indices: The indices into the frames
//! at which the Global landmarks are to be found. Assumed to be only 1 per slice.
morph::Matrix33<float> convertTwoDims (const string& datafile,
                                       const CmdOptions& co,
                                       const morph::Matrix33<float>& A3D,
                                       const std::array<unsigned int, 3>& frame_indices)
{
    morph::HdfData d(datafile, morph::FileAccess::ReadOnly);
    d.read_error_action = morph::ReadErrorAction::Exception;

    bool lmalignComputed = check_lmalignment(d);
    //bool autoalignComputed = check_autoalignment(d);
    bool align_lm = co.use_autoalign > 0 ? false : true;

    float xx = 0.0f;
    string frameName("");
    string str("");
    morph::Matrix33<float> A; // for return
    for (size_t fi = 0; fi < 3; ++fi) {

        stringstream ss;
        ss << "/Frame";
        ss.width(3);
        ss.fill('0');
        ss << frame_indices[fi];
        frameName = ss.str();

        // x position comes from the frame
        string str = frameName+"/class/layer_x";
        try {
            d.read_val (str.c_str(), xx);
        } catch (...) { return A; }

        // y position comes from a look at which of framePoints is closest to P.col(i)
        A[fi*3] = xx;

        morph::Vector<float, 3> gl = A3D.col(fi);
        float mindist = 1e9;

        vector<array<float, 12>> frameQuads_scaled;
        vector<array<float, 12>> frameQuads_lmaligned;
        vector<array<float, 12>> frameQuads_autoaligned;

        vector<morph::Vector<float>> framePoints_autoaligned;
        vector<morph::Vector<float>> framePoints_lmaligned;
        vector<morph::Vector<float>> framePoints_scaled;

        // Read quads and data for each frame and add to an overall pair of vectors...
        str = frameName+"/autoalign/sboxes";
        d.read_contained_vals (str.c_str(), frameQuads_autoaligned);
        str = frameName+"/lmalign/sboxes";
        d.read_contained_vals (str.c_str(), frameQuads_lmaligned);
        // Un-transformed:
        str = frameName+"/scaled/sboxes";
        d.read_contained_vals (str.c_str(), frameQuads_scaled);

        morph::Vector<float, 3> pt;
        size_t ii = 0;
        size_t min_idx = 0;
        if (co.flattened_type == 1) {
            // linear distance boxes
            ii = 0;
            for (auto fq : frameQuads_scaled) {
                pt = {fq[0],fq[1],fq[2]};
                float dist = (pt-gl).length();
                if (dist < mindist) {
                    mindist = dist;
                    min_idx = ii;
                }
                ++ii;
            }
        } else if (co.flattened_type == 2) {
            // angle based boxes
            throw std::runtime_error ("writeme");
        } else {
            // linear distance based on 0 angle starting point:
            if (lmalignComputed == true && align_lm == true) {
                // landmark aligned
                for (auto fq : frameQuads_lmaligned) {
                    morph::Vector<float, 3> pt = {fq[0],fq[1],fq[2]};
                    float dist = (pt-gl).length();
                    if (dist < mindist) {
                        mindist = dist;
                        min_idx = ii;
                    }
                    ++ii;

                }
            } else {
                // auto-aligned
                for (auto fq : frameQuads_autoaligned) {
                    // FIXME: Use centre of box, or even each end of box, or something
                    morph::Vector<float, 3> pt = {fq[0],fq[1],fq[2]};
                    float dist = (pt-gl).length();
                    if (dist < mindist) {
                        mindist = dist;
                        min_idx = ii;
                    }
                    ++ii;
                }
            }
        }
        std::cout << "Index of the quad that's closest to the global landmark: " << min_idx << std::endl;

        // Can now use min_idx to access the 'y' that we'll return in the matrix.
        vector<float> linbins;
        if (co.flattened_type == 1) {
            // linear distance boxes:
            str = frameName+"/scaled/flattened/sbox_linear_distance";
        } else if (co.flattened_type == 2) {
            // angle based boxes:
            str = frameName+"/lmalign/flattened/sbox_angles";
        } else {
            // linear distance based on 0 angle starting point:
            if (lmalignComputed == true && align_lm == true) {
                str = frameName+"/lmalign/flattened/sbox_linear_distance";
            } else {
                str = frameName+"/autoalign/flattened/sbox_linear_distance";
            }
        }
        d.read_contained_vals (str.c_str(), linbins);
        float y = linbins[min_idx];
        A[3*fi+1] = y;
        A[3*fi+2] = 1.0f;
    }

    std::cout << "The matrix A of 2D coords is\n" << A << std::endl;
    return A;
}

void computeFlatTransforms (const CmdOptions& co,
                            vector<morph::Matrix33<float>>& A,
                            vector<morph::Matrix33<float>>& M)
{
    if (co.datafiles.size() < 2) {
        // nothing to do though ensure M[0] contains identity, if necessary
        if (co.datafiles.size()==1 && M.size()==1) { M[0].setToIdentity(); }
        return;
    }

    if (co.datafiles.size() != M.size()) {
        std::cerr << "WARNING: datafiles and M have to have the same size. Returning.\n";
        return;
    }

    M[0].setToIdentity();

    // now the fun stuff. Get the relevant global landmark vectors
    std::array<unsigned int, 3> frame_indices;
    morph::Matrix33<float> _A3D = readGlobalPositions (co.datafiles[0], frame_indices);
    // How to get frame_indices? With readGlobalPositions i guess.
    morph::Matrix33<float> D = convertTwoDims (co.datafiles[0], co, _A3D, frame_indices);
    A[0] = D;

    // Now get 'A' matrices from datafiles[1] and up
    for (size_t di = 1; di < co.datafiles.size(); ++di) {
        morph::Matrix33<float> A3D = readGlobalPositions (co.datafiles[di], frame_indices);
        A[di] = convertTwoDims (co.datafiles[di], co, A3D, frame_indices);
        morph::Matrix33<float> Ainv = A[di].invert();
        M[di] = D * Ainv;
    }
}

/*!
 * Resampling function.
 *
 * \param coords (input) The x,y coordinates of the (centres of) input data pixels
 *
 * \param expression (input) The data for the pixels - in this program its a gene
 * expression signal
 *
 * \param extents (input) The spatial extents for the resampled data grid - can set to 0
 * to auto compute, but this wants to be the same for all images, so setting manually is
 * easiest. Should be configurable via the cmd line.
 *
 * \param cartgrid (output) The output cartesian grid. This will be resized by this
 * function
 *
 * \param expr_resampled (output) The output expression data on the cartesian grid. This
 * will be resized by this function
 *
 * \param sigma (input) vector of sigmas as (x, y, theta)
 *
 * \param l (input) The output pixel dimensions
 */
std::pair<unsigned int, unsigned int>
resample_twod (const vector<morph::Vector<float, 2>>& coords, // input coords
               const vector<float>& expression,               // input values
               const morph::Vector<float, 4>& extents,        // parameter - sets output extents
               vector<morph::Vector<float, 2>>& cartgrid,     // output domain (resized per extents)
               vector<float>& expr_resampled,                 // output values (resized per extents)
               const vector<morph::Vector<float, 3>> sigma,   // parameter - sigmas for ellip gaussians
               const morph::Vector<float, 2> l)               // parameter - how big are the output pixels?
{
    // Check input
    if (coords.size() != expression.size()) {
        std::stringstream ee;
        ee << "Expect coords (length " << coords.size()
           << ") and expression vectors (length " << expression.size() << ") to be same size";
        throw std::runtime_error (ee.str());
    }
    if (coords.size() < 2) {
        throw std::runtime_error ("Expect more than 1 coordinate!");
    }
    // Grid spacing is l (passed in)
    std::cout << "Image grid length, l is "<< l << std::endl;
    if (l.length() == 0.0f) { throw std::runtime_error ("l must be non-zero"); }

    // cout the input's max/min
    pair<float, float> imm = morph::MathAlgo::maxmin (expression);
    std::cout << "Input image max/min: " << imm.first << "/" << imm.second << std::endl;

    // Determine the output extents
    float minx = 1e9, miny = 1e9, maxx = -1e9, maxy = -1e9;
    if (extents.length() > 0.0f) {
        // Use passed-in extents
        minx = extents[0];
        maxx = extents[1];
        miny = extents[2];
        maxy = extents[3];
    } else {
        // Find the extents of the output grid
        for (auto c : coords) {
            minx = c[0] < minx ? c[0] : minx;
            miny = c[1] < miny ? c[1] : miny;
            maxx = c[0] > maxx ? c[0] : maxx;
            maxy = c[1] > maxy ? c[1] : maxy;
        }
    }

    // Count width and height to determine size of output
    unsigned int width_px = 0;
    for (float _x = minx; _x < maxx; _x += l[0]) { ++width_px; }
    unsigned int height_px = 0;
    for (float _y = miny; _y < maxy; _y += l[1]) { ++height_px; }
    cartgrid.resize (width_px * height_px);
    expr_resampled.resize (width_px * height_px);

    std::cout << "Image size " << width_px << "x" << height_px << std::endl
              << "EXTENTS: [" << minx << "," << maxx << "," << miny << "," << maxy << "]" << std::endl;

    size_t csz = coords.size();
    unsigned int yi = 0;
    for (float _y = miny; _y < maxy; _y += l[1], ++yi) {
        unsigned int xi = 0;
        for (float _x = minx; _x < maxx; _x += l[0], ++xi) {
            unsigned int idx = yi * width_px + xi;
            morph::Vector<float, 2> cartpos = {_x,_y};
            float expr = 0.0f;
#pragma omp parallel for reduction(+:expr)
            for (unsigned int i = 0; i < csz; ++i) {
                // Compute contributions to each pixel, using a rotated elliptical Gaussian
                float theta = sigma[i][2];
                float costheta = std::cos(theta);
                float sintheta = std::sin(theta);
                float sin2theta = std::sin(2.0f * theta);
                float a = costheta * costheta / (2.0f * sigma[i][0] * sigma[i][0])
                + sintheta * sintheta / (2.0f *  sigma[i][1] * sigma[i][1]);
                float b = (sin2theta/(4.0f * sigma[i][1] * sigma[i][1]))
                - (sin2theta/(4.0f * sigma[i][0] * sigma[i][0]));
                float c = sintheta * sintheta/(2.0f * sigma[i][0] * sigma[i][0])
                + costheta * costheta / (2.0f *  sigma[i][1] * sigma[i][1]);
                morph::Vector<float, 2> d = cartpos - coords[i];
                float w = std::exp ( -(a * d[0] * d[0]  +  2.0f * b * d[0] * d[1]  +  c * d[1] * d[1]));
                expr += w * expression[i];
            }
            //std::cout << "idx: " << idx << " cartpos: " << cartpos << " expr: " << expr << std::endl;
            cartgrid[idx] = cartpos;
            expr_resampled[idx] = expr;
        }
    }

    std::cout << "Computed resample for image of " << width_px << "x" << height_px << std::endl;
    // cout the input's max/min
    pair<float, float> omm = morph::MathAlgo::maxmin (expr_resampled);
    std::cout << "Resampled max/min: " << omm.first << "/" << omm.second << std::endl;
    return std::make_pair (width_px, height_px);
}

//! Add flattened map. 'A' contains the locations of the global landmarks, in 2D
//! coords. M contains the transformation matrices, to apply.
int addFlattened (SFVisual& v, const string& datafile, const CmdOptions& co,
                  morph::Matrix33<float>& A,
                  morph::Matrix33<float>& M,
                  morph::Vector<float> offset = { 0.0f, 0.0f, 0.0f })
{
    int rtn = 0;

    bool autoscale_per_slice = co.scale_perslice > 0 ? true : false;
    bool align_lm = co.use_autoalign > 0 ? false : true;

    // THIS needs to handle missing data in some slices
    try {

        morph::Scale<float> scale;
        scale.setParams (1.0, 0.0);

        float thickness = 0.0f;
        float xx = 0.0f;
        float lastxx = -1e7;
        vector<array<float, 12>> fquads; // Flat quads, for the flat visualization
        vector<morph::Vector<float, 2>> fmids; // Mid points of the quads
        vector<float> means;
        vector<float> fmeans;

        {
            string datafile2(datafile);
            morph::Tools::stripFileSuffix (datafile2);
            datafile2 += ".TF.";
            pair<string, string> dfpaf = morph::Tools::getUnixPathAndFile (co.datafiles[0]);
            datafile2 += dfpaf.second; // already has .h5 suffix
            cout << "Opening H5 file " << datafile << " and associated file " << datafile2 << endl;

            morph::HdfData d(datafile, morph::FileAccess::ReadOnly);
            morph::HdfData d2(datafile2, morph::FileAccess::TruncateWrite);
            d2.read_error_action = morph::ReadErrorAction::Continue;

            int nf = 0;
            d.read_val ("/nframes", nf);

            // Check first frame for alignments
            bool lmalignComputed = check_lmalignment(d);
            //bool autoalignComputed = check_autoalignment(d);

            if (co.flattened_type == 1) {
                // linear distance boxes:
                std::cout << "Showing centered, linear distance as y axis for 2D map.\n";
            } else if (co.flattened_type == 2) {
                // angle based boxes:
                std::cout << "Showing angle as y axis for 2D map.\n";
            } else {
                // linear distance based on 0 angle starting point:
                if (lmalignComputed == true && align_lm == true) {
                    std::cout << "Showing linear distance unwrapped from 3D landmark aligned reconstruction as y axis for 2D map.\n";
                } else {
                    std::cout << "Showing linear distance unwrapped from 3D auto-aligned reconstruction as y axis for 2D map.\n";
                }
            }

            // Need this loop to graciously handle missing slice data
            string frameName("");
            for (int i = 1; i<=nf; ++i) {

                stringstream ss;
                ss << "/Frame";
                ss.width(3);
                ss.fill('0');
                ss << i;
                frameName = ss.str();

                // x position comes from FrameNNN/class/layer_x
                string str = frameName+"/class/layer_x";
                d.read_val (str.c_str(), xx);
                str = frameName+"/class/thickness";
                d.read_val (str.c_str(), thickness);
                vector<float> frameMeansF;
                try {
                    if (autoscale_per_slice) {
                        // Use the auto-scaled version of the means, with each slice autoscaled to [0,1]
                        str = frameName+"/signal/postproc/boxes/means_autoscaled";
                        d.read_contained_vals (str.c_str(), frameMeansF);
                    } else {
                        // Use the raw means and autoscale them as an entire group
                        str = frameName+"/signal/postproc/boxes/means";
                        d.read_contained_vals (str.c_str(), frameMeansF);
                        // The morph::Scale object scales the whole thing with autoscale set true.
                        scale.do_autoscale = true;
                    }
                } catch (const exception& ee) {
                    // Perhaps this slice has no curve on it. Handle this by leaving frameMeans empty and continuing
                    std::cout << "no boxes/means for slice " << i << std::endl;
                    continue;
                }

                // Load in linear stuff as well, to make up flat boxes? Or easier to do at source?
                vector<float> linbins;
                if (co.flattened_type == 1) {
                    // linear distance boxes:
                    str = frameName+"/scaled/flattened/sbox_linear_distance";
                } else if (co.flattened_type == 2) {
                    // angle based boxes:
                    str = frameName+"/lmalign/flattened/sbox_angles";
                } else {
                    // linear distance based on 0 angle starting point:
                    if (lmalignComputed == true && align_lm == true) {
                        str = frameName+"/lmalign/flattened/sbox_linear_distance";
                    } else {
                        str = frameName+"/autoalign/flattened/sbox_linear_distance";
                    }
                }
                d.read_contained_vals (str.c_str(), linbins);

                // now - if the linbins we loaded were the sbox_angles, then we need to
                // sort linbins, while sorting, at the same time, the signals.

                // The corners of the boxes to be drawn, in 3D (though z will be 0)
                vector<array<float,12>> flatsurf_boxes;
                // The centroids of the boxes, in the 2D plane.
                vector<morph::Vector<float, 2>> flat_mids;
                array<float, 12> sbox;
                for (unsigned int j = 1; j < linbins.size(); ++j) {

                    // c1 x,y,z
                    morph::Vector<float> c1 = {0,0,0};
                    if (lastxx < -100000 || co.show_slice_thickness > 0) {
                        c1 = { xx-thickness, linbins[j-1], 1.0f };
                    } else {
                        c1 = { lastxx, linbins[j-1], 1.0f };
                    }
                    morph::Vector<float> c1p = M * c1;
                    sbox[0] = c1p[0]; // x
                    sbox[1] = c1p[1]; // y
                    sbox[2] = 0.0;    // z
                    // c2 x,y,z
                    c1[1] = linbins[j];
                    c1p = M * c1;
                    sbox[3] = c1p[0];
                    sbox[4] = c1p[1];
                    sbox[5] = 0.0;
                    // c3 x,y,z
                    c1[0] = xx;
                    c1p = M * c1;
                    sbox[6] = c1p[0];
                    sbox[7] = c1p[1];
                    sbox[8] = 0.0;
                    // c4 x,y,z
                    c1[1] = linbins[j-1];
                    c1p = M * c1;
                    sbox[9] = c1p[0];
                    sbox[10] = c1p[1];
                    sbox[11] = 0.0;

                    // For angle based view, have to tweak the box angles by +-2pi to avoid boxes that span the whole ribbon.
                    if (co.flattened_type == 2) {
                        if (std::abs(sbox[1] - sbox[4])  > morph::PI_F && std::abs(sbox[7] - sbox[10]) > morph::PI_F) {
                            //std::cout << "PROBLEM BOX\n";
                            if (sbox[4] < 0) {
                                sbox[4] += morph::TWO_PI_F;
                                sbox[7] += morph::TWO_PI_F;
                            } else {
                                sbox[4] -= morph::TWO_PI_F;
                                sbox[7] -= morph::TWO_PI_F;
                            }
                        }
                    }
#if 0 // DEBUG
                    if (j==1) {
                        std::cout << "Original:\nc1: (" << sbox[0]  << "," << sbox[1] << ")\n"
                                  << "c2: (" << sbox[3]  << "," << sbox[4] << ")\n"
                                  << "c3: (" << sbox[6]  << "," << sbox[7] << ")\n"
                                  << "c4: (" << sbox[9]  << "," << sbox[10] << ")\n";
                    }
#endif
                    flatsurf_boxes.push_back (sbox);
                    morph::Vector<float, 2> midpoint = { (sbox[0] + sbox[3] + sbox[6] + sbox[9]) * 0.25f,
                                                         (sbox[1] + sbox[4] + sbox[7] + sbox[10]) * 0.25f };
                    flat_mids.push_back (midpoint);
                }

                try {
                    // Try inserting frameMeansF first, as this may throw an error, in which case, move on
                    fmeans.insert (fmeans.end(), frameMeansF.begin(), --frameMeansF.end());
                    fquads.insert (fquads.end(), flatsurf_boxes.begin(), flatsurf_boxes.end());
                    fmids.insert (fmids.end(), flat_mids.begin(), flat_mids.end());
                } catch (...) {
                    // std::cout << "Failed; there was no 2D ribbon for slice " << i << std::endl;
                }
                lastxx = xx;
            }
            unsigned int visId = 0;

            // This is the flattened map; showing it alongside the 3D map for now
            offset[0]+=-5.5;
            visId = v.addVisualModel (new morph::QuadsVisual<float> (v.shaderprog,
                                                                     &fquads, offset,
                                                                     &fmeans, scale,
                                                                     morph::ColourMapType::Greyscale));
            v.surfaces_2d.push_back (visId);

            // Add the newly-generated expression and coordinates to the data file.
            d2.add_contained_vals ("/output_map/twod/expression", fmeans);
            d2.add_contained_vals ("/output_map/twod/coordinates", fmids);

            // Resample onto a rectangular grid
            vector<morph::Vector<float, 2>> fmids_resampled;
            vector<float> fmeans_resampled;
            //float x1, x2;
            //d.read_val ("/Frame001/class/layer_x", x1);
            //d.read_val ("/Frame002/class/layer_x", x2);
            // The base_grid is the size of the origin grid elements
            // morph::Vector<float, 2> base_grid = {std::abs (x2-x1), std::abs (fmids[1][1]-fmids[0][1])};
            // l gives the length scales for the rectangular, resampled grid
            morph::Vector<float, 2> l = { 0.025f, 0.025f }; // whence 0.025?
            std::cout << "l = " << l << std::endl;

            // Compute area of origin 'pixels'.
            size_t fqs = fquads.size();
            vector<morph::Vector<float, 3>> sigma(fqs);
            for (unsigned int i = 0; i < fquads.size(); ++i) {
                // c1, c2 and c3 are corners on the origin pixel
                morph::Vector<float, 2> c1 = {fquads[i][0], fquads[i][1]};
                morph::Vector<float, 2> c2 = {fquads[i][3], fquads[i][4]};
                morph::Vector<float, 2> c3 = {fquads[i][6], fquads[i][7]};
                // from which get two vector lengths for the sigma
                morph::Vector<float, 2> xprime = (c3 - c2);
                morph::Vector<float, 2> yprime = (c1 - c2);
                sigma[i][0] = xprime.length() * 0.5f; // 'x length'. length * 0.5 gives minimum smoothing. Increase to blur.
                sigma[i][1] = yprime.length() * 0.5f; // 'y length'
                sigma[i][2] = std::atan2 (xprime[1], xprime[0]);
            }

            // extents is: { minx, maxx, miny, maxy, }. Set all 0 to auto-determine
            std::pair<unsigned int, unsigned int> wh = resample_twod (fmids, fmeans,
                                                                      cmdOptions.extents, fmids_resampled,
                                                                      fmeans_resampled, sigma, l);

            // Convert fmids_resampled into quads
            size_t n_re = fmids_resampled.size();
            std::cout << "There are " << n_re << " resampled coordinates\n";
            float halflx = l[0]*0.5f;
            float halfly = l[1]*0.5f;
            vector<array<float, 12>> fquads_re (n_re); // Flat quads, for the flat visualization
            for (unsigned int i = 0; i < n_re; ++i) {
                float _x = fmids_resampled[i][0];
                float _y = fmids_resampled[i][1];
                fquads_re[i][0] = _x-halflx;
                fquads_re[i][1] = _y+halfly;
                fquads_re[i][2] = 0.0f;

                fquads_re[i][3] = _x-halflx;
                fquads_re[i][4] = _y-halfly;
                fquads_re[i][5] = 0.0f;

                fquads_re[i][6] = _x+halflx;
                fquads_re[i][7] = _y-halfly;
                fquads_re[i][8] = 0.0f;

                fquads_re[i][9] = _x+halflx;
                fquads_re[i][10] = _y+halfly;
                fquads_re[i][11] = 0.0f;
            }
            // And turn them into a graph
            offset[1]+=7.5f;
            //scale.setAutoscale (fmeans_resampled); or something
            std::cout << "Adding resampled graph at offset " << offset << std::endl;
            visId = v.addVisualModel (new morph::QuadsVisual<float> (v.shaderprog,
                                                                     &fquads_re, offset,
                                                                     &fmeans_resampled, scale,
                                                                     morph::ColourMapType::Greyscale));
            v.surfaces_2d.push_back (visId);

            // Add a plain VisualModel whose reason for inclusion is just for text
            offset[1]+=5.0f;
            auto jtvm = new morph::VisualModel (v.shaderprog, v.tshaderprog, offset);
            jtvm->addLabel (datafile, {1.0f, 0.0f, 0.0f},
                            (cmdOptions.whitebg > 0 ? morph::colour::black : morph::colour::white),
                            morph::VisualFont::Vera, 0.2, 24);
            v.addVisualModel (jtvm);
            offset[1]-=5.0f;
            offset[1]-=7.5f;

            d2.add_contained_vals ("/output_map/twod/M", M.mat);

            // Add a row of points for the centre marker, for debugging
            vector<morph::Vector<float>> centres_;
            vector<float> centres_id;
            for (int i = 1; i < nf; ++i) {
                stringstream ss;
                ss << "/Frame";
                ss.width(3);
                ss.fill('0');
                ss << i;
                frameName = ss.str();
                string str = frameName+"/class/layer_x";
                d.read_val (str.c_str(), xx);
                morph::Vector<float> cp;
                cp[0] = xx;
                cp[1] = 0;
                cp[2] = 0;
                centres_.push_back (M*cp);
                centres_id.push_back (0.1f*(float)i);
            }


            auto sv1 = new morph::ScatterVisual<float> (v.shaderprog, offset);
            sv1->setDataCoords (&centres_);
            sv1->setScalarData (&centres_id);
            sv1->radiusFixed = 0.03f;
            sv1->colourScale = scale;
            sv1->cm.setType (morph::ColourMapType::Jet);
            sv1->finalize();
            visId = v.addVisualModel (sv1);

            v.angle_centres.push_back (visId);

            // Plot A (the landmarks) if necessary.
            std::vector<morph::Vector<float,3>> sc_coords(3);
            std::vector<float> sc_data = { 0.2f, 0.4f, 0.6f };
            sc_coords[0] = A.col(0); sc_coords[0][2] = 1.0f;
            sc_coords[1] = A.col(1); sc_coords[1][2] = 1.0f;
            sc_coords[2] = A.col(2); sc_coords[2][2] = 1.0f;
            // Apply transform
            for (unsigned int j = 0; j < 3; ++j) {
                sc_coords[j] = M * sc_coords[j];
                sc_coords[j][2] = 0.0f;
            }
            auto sv2 = new morph::ScatterVisual<float> (v.shaderprog, offset);
            sv2->setDataCoords (&sc_coords);
            sv2->setScalarData (&sc_data);
            //sv2->radiusFixed = 0.03f;
            sv2->colourScale = scale;
            sv2->cm.setType (morph::ColourMapType::Jet);
            sv2->finalize();
            visId = v.addVisualModel (sv2);

            v.surfaces_2d.push_back (visId);

            // Save the resampled stuff to file
            std::cout << "saving resampled...\n" << std::endl;
            d2.add_contained_vals ("/output_map/twod/widthheight_resampled", wh);
            d2.add_contained_vals ("/output_map/twod/expression_resampled", fmeans_resampled);
            d2.add_contained_vals ("/output_map/twod/coordinates_resampled", fmids_resampled);
            // FIXME: Convert to 2D then save. Here are landmarks in 3D:
            d2.add_contained_vals ("/output_map/twod/global_landmarks", sc_coords);
            // Finally, add the datafile used to determine M.
            d2.add_string ("/output_map/twod/M_comes_from", co.datafiles[0]);
        }
    } catch (const exception& e) {
        cerr << "Caught exception: " << e.what() << endl;
        rtn = -1;
    }

    return rtn;
}

// Find the bundled example project file
std::string exampleProjectPath (const std::string& argv0)
{
    // First try relative path, if this is being run from the git repository root
    std::string ex_project_path("data/vole_65_7E_id2_L23.h5");
    if (morph::Tools::fileExists (ex_project_path)) { return ex_project_path; }

    // Try Mac path, if this is a bundled Mac app. Use argv0 as starting point.
    ex_project_path = argv0;
    morph::Tools::stripUnixFile(ex_project_path);
    ex_project_path += std::string("/../Resources/vole_65_7E_id2_L23.h5");
    if (morph::Tools::fileExists (ex_project_path)) { return ex_project_path; }

    // For the snap, we also use the argv0 to start from
    ex_project_path = argv0;
    morph::Tools::stripUnixFile(ex_project_path);
    ex_project_path += std::string("/../share/vole_65_7E_id2_L23.h5");
    if (morph::Tools::fileExists (ex_project_path)) { return ex_project_path; }

    return std::string("");
}

int main (int argc, char** argv)
{
    int rtn = -1;

#ifdef __OSX__
    // On Mac, in case we are being run from a 'bundle', save the working directory for later.
    sfview::working_directory = morph::Tools::getPwd();
    std::cout << "Program working dir: '" << sfview::working_directory << "'" << std::endl;
#endif

    // popt command line argument processing setup
    zeroCmdOptions (&cmdOptions);

    struct poptOption opt[] = {
        POPT_AUTOHELP

        {"scale_perslice", 'p',
         POPT_ARG_NONE, &(cmdOptions.scale_perslice), 0, // 0 is 'val' which is available in callbacks
         "If set, auto-scale the signal for each slice."},

        {"use_autoalign", 'a',
         POPT_ARG_NONE, &(cmdOptions.use_autoalign), 0,
         "If set, prefer the auto-alignment (based on the curve points only) rather than landscape alignment."},

        {"show_ribbons", 'r',
         POPT_ARG_NONE, &(cmdOptions.show_ribbons), 0,
         "If set, display the ribbon-like surface boxes, rather than the smoothed surface."},

        {"show_mesh", 's',
         POPT_ARG_NONE, &(cmdOptions.show_mesh), 0,
         "If set, display the mesh version of the surface."},

        {"show_example", 'e',
         POPT_ARG_NONE, &(cmdOptions.show_example), 0,
         "Show an example project."},

        {"lighting", 'g',
         POPT_ARG_NONE, &(cmdOptions.lighting), 0,
         "If set, apply ambient/diffuse lighting in the shader."},

        {"whitebg", 'w',
         POPT_ARG_NONE, &(cmdOptions.whitebg), 0,
         "If set, make the sfview background white, not black."},

        {"hide_colour", 'c',
         POPT_ARG_NONE, &(cmdOptions.hide_colour), 0,
         "If set, hide the colour that indicates the ISH expression data value."},

        {"show_landmarks", 'l',
         POPT_ARG_INT, &(cmdOptions.show_landmarks), 0,
         "Display landmarks from the indexed (counting from 1) data file."},

        {"show_landmarks_all", 'L',
         POPT_ARG_NONE, &(cmdOptions.show_landmarks_all), 0,
         "If set, display landmarks from ALL first data files."},

        {"show_flattened", 'm',
         POPT_ARG_INT, &(cmdOptions.show_flattened), 0,
         "Display flattened image from the data file with this index (counting from 1), to compare with 3D."},

        {"flattened_type", 't',
         POPT_ARG_INT, &(cmdOptions.flattened_type), 0,
         "Selects the type of flattened map to show: 0 (default): use aligned 3D image and compute linear "
         "distance along the curve starting from the surface box that is on the zero degree line wrt the "
         "origin. 1: Use centered surface box linear distance. 2: Plot vs. the angle of the surface box."},

        {"linear_transforms", 'T',
         POPT_ARG_NONE, &(cmdOptions.linear_transforms), 0,
         "If there is more than one model, then transform each model index > 0 to match model index 0, using global "
         "landmarks of which there should be 4 in each model (for 3D transforms) or 3 in each (for 2D transforms)."},

        {"show_slice_thickness", 'I',
         POPT_ARG_NONE, &(cmdOptions.show_slice_thickness), 0,
         "If true, then plot slices on 2D maps with the thickness of the slice given in the projects json settings. "
         "Otherwise, plot slices from the current x, to the next x (to give a continuous map. Relevant if you have "
         "interleaved slices marked for different genes, as with the Allen Developing Mouse Atlas."},

        // options following this will cause the popt_option_callback to be executed.
        { "callback", '\0',
          POPT_ARG_CALLBACK|POPT_ARGFLAG_DOC_HIDDEN, (void*)&popt_option_callback, 0,
          NULL, NULL },

        {"datafile", 'f',
         POPT_ARG_STRING, &(cmdOptions.datafile), 0,
         "Add a data file to visualise in 3D. Provide an argument like /path/to/file.h5. "
         "This option can be used multiple times, and you can even leave the -f out; any "
         "'non-option' strings on your command line will be interpreted as data files."},

        {"extents", 'x',
         POPT_ARG_STRING, &(cmdOptions.extents_str), 0,
         "Provide a string for the extents of the resampled map (when you produce 2D maps)"
         ". Allows all resampled maps to be same size. Format: xmin,xmax,ymin,ymax so "
         "e.g.: -0.22,4.65,-3.03,3.85"},

        POPT_AUTOALIAS
        POPT_TABLEEND
    };
    poptContext con;
    con = poptGetContext (argv[0], argc, (const char**)argv, opt, 0);
    while (poptGetNextOpt(con) != -1) {}
    const char* argg = (char*)0;
    while ((argg = poptGetArg(con)) != (char*)0) {
        // Treat any extra args as files.
        cmdOptions.datafiles.push_back (string(argg));
    }

    if (cmdOptions.show_example && cmdOptions.datafiles.empty()) {
        std::cout << "Attempting to open the example project file...\n";
        std::string ex_file =  exampleProjectPath(std::string(argv[0]));
        if (!ex_file.empty()) {
            cmdOptions.datafiles.push_back (ex_file);
        } else {
            std::cout << "Failed to find the example project data\n";
        }
    } else if (cmdOptions.show_example && cmdOptions.datafiles.empty() == false) {
        // Prevent 'it's an example' text showing up, as user provided a file.
        cmdOptions.show_example = 0;
    }

    try {
        if (cmdOptions.datafiles.empty()) {
            throw std::runtime_error ("Please supply at least one HDF5 file with the -f option.\nYou can also view an example project with the -e option. -? shows help.");
        }
    } catch (const exception& e) {
        cerr << "Error: " << e.what() << endl;
        rtn = -1;
        poptFreeContext(con);
        return rtn;
    }
    // End processing options. Can now access options via cmdOptions

    // Visual scene for all models
    morph::Vector<float, 2> coordArrowLocn = {-0.75,-0.7};
    morph::Vector<float> coordArrowLengths = {0.14f, 0.07f, 0.07f};
    SFVisual v(2000, 1400, cmdOptions.datafiles[0], coordArrowLocn, coordArrowLengths, 1.0f, 0.01f);
#ifdef __OSX__
    // If this is a Mac OS app in a 'bundle', then instatiating SFVisual will have caused the
    // working directory to have been set to 'Package/Contents/Resources' (at the moment that
    // the morph::Visual::init function attempted to open /tmp/Visual.json). Here, I switch it
    // back to the working directory that was set when the program started (i.e. the working
    // directory of the command line from which sfview was called). This is annoying Mac OS
    // behaviour. A thousand and twenty four curses on Apple Inc!
    morph::Tools::setPwd (sfview::working_directory);
#endif
    v.zNear = 0.0001;
    v.zFar = 1000.0;
    v.showTitle = false;
    v.showCoordArrows = true;
    v.coordArrowsInScene = false;
    if (cmdOptions.whitebg > 0) { v.backgroundWhite(); }
    // Enable lighting if asked for, or automatically for mesh views
    if (cmdOptions.lighting > 0 || cmdOptions.show_mesh > 0) {
        v.lightingEffects (true);
    }
    if (cmdOptions.show_example) {
        std::stringstream exmsg;
        exmsg << "This is the example project data\n"
              << "(Vole, P0, Id2, superficial cortical layers)\n"
              << "See `" << argv[0] << " -?` for command options";
#ifdef __OSX__
        v.addLabel (exmsg.str(), {-0.05f, -0.2f, 0.0f});
#else
        v.addLabel (exmsg.str(), {-0.05f, 0.005f, 0.0f});
#endif
    }
    v.diffuse_position = {-1, 2, -3};

    unsigned int n_global_landmarks = 0;
    if (cmdOptions.datafiles.size() > 1) {
        // Count how many landmarks in the first datafile:
        n_global_landmarks = countGlobalLandmarks (cmdOptions.datafiles[0]);
        std::cout << "First data file contains " << n_global_landmarks << " global landmarks.\n";
    }

    // Before addVisMod(), addLandmarks(), etc, and if there is more than 1 model and if
    // the "compute linear transformations" option is true, then compute linear
    // transformations that should be applied to each model index > 0.
    vector<morph::TransformMatrix<float>> M(cmdOptions.datafiles.size());
    if (cmdOptions.linear_transforms > 0 && cmdOptions.datafiles.size() > 1 && n_global_landmarks == 4) {
        std::cout << "Applying 3D linear transforms...\n";
        computeTransforms (cmdOptions.datafiles, M, cmdOptions);
    }

    // For each file in cmdOptions.datafiles:
    for (unsigned int ii = 0; ii < cmdOptions.datafiles.size(); ++ii) {
        float hue = get_sfview_hue (ii);
        // Pass M into addVisMod and apply to the coords therein.
        std::cout << "Calling addVisMod (...,M["<<ii<<"] with hue " << hue << "\n";
        rtn += addVisMod (v, cmdOptions.datafiles[ii], cmdOptions, hue, M[ii]);
    }

    // And landmarks
    std::cout << "show_landmarks: " << cmdOptions.show_landmarks << "\n";
    if (cmdOptions.show_landmarks_all) {
        for (unsigned int ii = 0; ii < cmdOptions.datafiles.size(); ++ii) {
            //std::cout << "Add landmarks, multiplying positions by\n" << M[ii] << std::endl;
            rtn += addLandmarks (v, cmdOptions.datafiles[ii], cmdOptions, M[ii], 1+ii);
        }
    } else {
        if (cmdOptions.show_landmarks > 0 && static_cast<int>(cmdOptions.datafiles.size()) >= cmdOptions.show_landmarks) {
            unsigned int ii = cmdOptions.show_landmarks-1;
            //std::cout << "Add landmarks (one-off), multiplying positions by\n" << M[ii] << std::endl;
            rtn += addLandmarks (v, cmdOptions.datafiles[ii], cmdOptions, M[ii], 1);
        }
    }

    // Add requested flattened, 2D map
    if (cmdOptions.show_flattened > 0) {
        // Compute the 2D transforms. D2 = M2 * A2
        std::vector<morph::Matrix33<float>> M2(cmdOptions.datafiles.size()); // Will be constructed with identity matrices
        std::vector<morph::Matrix33<float>> A2(cmdOptions.datafiles.size());
        for (size_t mi = 0; mi < M2.size(); ++mi) { std::cout << "M2["<<mi<<"]=" << M2[mi] << std::endl; }
        for (size_t ai = 0; ai < A2.size(); ++ai) { std::cout << "A2["<<ai<<"]=" << A2[ai] << std::endl; }

        if (cmdOptions.linear_transforms > 0 && cmdOptions.datafiles.size() > 1 && n_global_landmarks == 3) {

            std::cout << "Applying 2D linear transforms...\n";
            computeFlatTransforms (cmdOptions, A2, M2);
            // Display flattened (and transformed) maps
            float xoffs = 0.0f;
            size_t dfi = 0;
            for (auto df : cmdOptions.datafiles) {
                rtn += addFlattened (v, df, cmdOptions, A2[dfi], M2[dfi], {xoffs, 0, 0});
                xoffs += -6.0f;
                dfi++;
            }

        } else if (cmdOptions.linear_transforms > 0 && cmdOptions.datafiles.size() > 1 && n_global_landmarks == 4) {
            std::cout << "NB: 3D transform will have been applied. THIS code should achieve a suitable unwrapping of the data.\n";
            // What I need to do here (in a loop): Transform the 3D surface positions
            // using M[di]. Unwrap the transformed points to give the map. Done.
#ifdef OLD
            // This is reading global positions and converting to 2D, right?:
            // Would like to get A2 populated with untransformed coords here.
            std::array<unsigned int, 3> frame_indices;
            for (size_t di = 0; di < cmdOptions.datafiles.size(); ++di) {
                morph::Matrix33<float> A3D = readGlobalPositions (cmdOptions.datafiles[di], frame_indices);
                A2[di] = convertTwoDims (cmdOptions.datafiles[di], cmdOptions, A3D, frame_indices);
            }
#endif

        } else {
            std::cout << "NB: There was not the right number of global landmarks for transformations, just show untransformed flattened maps.\n";
            // Display flattened (but UNtransformed) maps
            float xoffs = 0.0f;
            size_t dfi = 0;
            for (auto df : cmdOptions.datafiles) {
                rtn += addFlattened (v, df, cmdOptions, A2[dfi], M2[dfi], {xoffs, 0, 0});
                xoffs += -6.0f;
                dfi++;
            }
        }
    }

    try {
        v.render();
        while (v.readyToFinish == false) {
            glfwWaitEventsTimeout (0.018);
            v.render();
        }

    } catch (const exception& e) {
        cerr << "Caught exception: " << e.what() << endl;
        rtn = -1;
    }

    poptFreeContext(con);
    return rtn;
}
