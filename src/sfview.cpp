/*
 * A 3D viewer for the data generated by Stalefish
 */
#include <morph/Visual.h>
#include <morph/HdfData.h>
#include <morph/Vector.h>
#include <iostream>
#include <fstream>
#include <cmath>
#include <array>
#include <morph/PointRowsVisual.h>
#include <morph/PointRowsMeshVisual.h>
#include <morph/ScatterVisual.h>
#include <morph/QuadsVisual.h>
#include <morph/QuadsMeshVisual.h>
#include <morph/RodVisual.h>
#include <morph/TransformMatrix.h>
#include <morph/Matrix33.h>
#include <popt.h>

using namespace std;

// Derive Visual to add the extra sfview-specific keyhandling callback
class SFVisual : public morph::Visual
{
public:
    SFVisual (int width, int height, const std::string& title,
              const morph::Vector<float, 2> caOffset, const morph::Vector<float> caLength,
              const float caThickness, const float caEm)
        : morph::Visual (width, height, title, caOffset, caLength, caThickness, caEm) {}

    //! Vector of VisualModel IDs for the landmarks. To hide landmarks, hide these.
    std::vector<unsigned int> landmarks;
    //! The 'angle=0' lines - in Jet colours
    std::vector<unsigned int> angle_centres;
    //! The axis (or axes) from 'axis marks'
    std::vector<unsigned int> axes;
    //! The 3D surfaces
    std::vector<unsigned int> surfaces_3d;
    //! 2D surfaces
    std::vector<unsigned int> surfaces_2d;

protected:
    //! Act on keys and toggle 'hidden' for the relevant VisualModels
    virtual void key_callback_extra (GLFWwindow* window, int key, int scancode, int action, int mods)
    {
        // Landmarks
        if (key == GLFW_KEY_F && action == GLFW_PRESS) {
            for (auto id : this->landmarks) { this->vm[id]->toggleHide(); }
        }
        // Angle markers
        if (key == GLFW_KEY_G && action == GLFW_PRESS) {
            for (auto id : this->angle_centres) { this->vm[id]->toggleHide(); }
        }
        // axes
        if (key == GLFW_KEY_D && action == GLFW_PRESS) {
            for (auto id : this->axes) { this->vm[id]->toggleHide(); }
        }
        // 2D map
        if (key == GLFW_KEY_J && action == GLFW_PRESS) {
            for (auto id : this->surfaces_2d) { this->vm[id]->toggleHide(); }
        }
        // 3D map
        if (key == GLFW_KEY_K && action == GLFW_PRESS) {
            for (auto id : this->surfaces_3d) { this->vm[id]->toggleHide(); }
        }

        // Additional help
        if (key == GLFW_KEY_H && action == GLFW_PRESS) {
            std::cout << "sfview help:\n";
            std::cout << "f: toggle (show/hide) landmarks\n";
            std::cout << "g: toggle zero angle marks\n";
            std::cout << "d: toggle user-defined brain axis\n";
            std::cout << "j: toggle 2D brain map\n";
            std::cout << "k: toggle 3D brain surface\n";
        }
    }
};

//! libpopt features - the features that are available to change on the command line.
struct CmdOptions
{
    //! If true, then autoscale the signal for each slice
    int scale_perslice;
    //! If true, then use auto align, even if landmark alignment data is present
    int use_autoalign;
    //! If true, plot ribbons for 3D instead of the smooth surface map. Useful for debugging
    int show_ribbons;
    //! If true, plot the meshy version of the surface, with no colour
    int show_mesh;
    //! If true, use ambient/diffuse lighting
    int lighting;
    //! If true, hide colour map and plot in white.
    int hide_colour;
    //! Show landmarks from first model
    int show_landmarks;
    //! Show landmarks from all models
    int show_landmarks_all;
    //! Takes the index of the flattened map to show
    int show_flattened;
    //! flattened_type could be 0. aligned linear distance, starting from angle 0 1. linear distance, centered, 2. angle of thing about 0.
    int flattened_type;
    //! Apply Linear Transforms based on global landmarks
    int linear_transforms;
    //! Temporary datafile, for adding to datafiles.
    char* datafile;
    //! The h5 files to visualize
    std::vector<string> datafiles;
};

//! Initialise a CmdOptions object
void zeroCmdOptions (CmdOptions* copts)
{
    copts->scale_perslice = 0;
    copts->use_autoalign = 0;
    copts->show_ribbons = 0;
    copts->show_mesh = 0;
    copts->lighting = 0;
    copts->hide_colour = 0; // Default to showing colour
    copts->show_landmarks = 1;
    copts->show_landmarks_all = 0;
    copts->show_flattened = 0;
    copts->flattened_type = 0;
    copts->linear_transforms = 0;
    copts->datafile = (char*)0;
    copts->datafiles.clear();
}

//! cmdOptions is global, allowing callbacks to access this easily.
struct CmdOptions cmdOptions;

/*!
 * This callback is used when there's a -f option, to allow me to
 * collect multiple files for visualization (e.g. to vis. multiple layers)
 *
 * e.g. viewer -f /path/to/ctx_superficial.h5 -f /path/to/ctx_mid.h5
 */
void popt_option_callback (poptContext con,
                           enum poptCallbackReason reason,
                           const struct poptOption * opt,
                           const char * arg,
                           void * data)
{
    switch(reason) {
    case POPT_CALLBACK_REASON_PRE: { break; } // Doesn't occur
    case POPT_CALLBACK_REASON_POST: { break; } // Ignore
    case POPT_CALLBACK_REASON_OPTION:
    {
        // Test shortName. This means we could respond to other "multiple options"
        if (opt->shortName == 'f') {
            cmdOptions.datafiles.push_back (cmdOptions.datafile);
        }
        break;
    }
    }
}

morph::TransformMatrix<float> readGlobalMatrix (const std::string& datafile)
{
    morph::TransformMatrix<float> A;
    morph::HdfData d(datafile, true); // true for read
    int nf = 0;
    d.read_val ("/nframes", nf);

    // Check first frame for alignments
    bool lmalignComputed = false;
    d.read_val ("/Frame001/lmalign/computed", lmalignComputed);
    bool autoalignComputed = false;
    d.read_val ("/Frame001/autoalign/computed", autoalignComputed);
    string frameName("");

    // Get global landmarks
    std::vector<std::pair<unsigned int, unsigned int>> glm_table;
    d.read_contained_vals ("/global_landmarks", glm_table);
    vector<array<float, 3>> allGLM;
    for (auto glmt : glm_table) {
        //std::cout << "Frame: " << glmt.first << ", index: " << glmt.second << std::endl;
        stringstream ss;
        ss << "/Frame";
        ss.width(3);
        ss.fill('0');
        if (lmalignComputed == true) {
            ss << glmt.first << "/lmalign/global_landmarks";
        } else {
            ss << glmt.first << "/autoalign/global_landmarks";
        }
        frameName = ss.str();
        vector<array<float, 3>> GLM;
        //std::cout << "Reading global landmark in " << frameName << std::endl;
        d.read_contained_vals(frameName.c_str(), GLM);

        allGLM.push_back (GLM[glmt.second]);
    }
    if (allGLM.size() < 4) {
        std::cerr << "Need at least 4 global landmarks.\n";
        return A;
    }

    // Can loop through first 4 entries in GLM
    for (size_t i = 0; i < 4; ++i) {
        size_t start = i*4;
        for (size_t j = 0; j<3; ++j) {
            A[start+j] = allGLM[i][j];
        }
        A[start+3] = 1;
    }

    return A;
}

//! Compute linear transformations to apply to datafiles
void computeTransforms (const vector<string>& datafiles,
                        vector<morph::TransformMatrix<float>>& trans_mats,
                        const CmdOptions& co)
{
    if (datafiles.size() < 2) {
        // nothing to do though ensure trans_mats[0] contains identity, if necessary
        if (datafiles.size()==1 && trans_mats.size()==1) { trans_mats[0].setToIdentity(); }
        return;
    }

    if (datafiles.size() != trans_mats.size()) {
        std::cerr << "WARNING: datafiles and trans_mats have to have the same size. Returning.\n";
        return;
    }

    trans_mats[0].setToIdentity();

    // now the fun stuff. Get the relevant global landmark vectors
    morph::TransformMatrix<float> D = readGlobalMatrix (datafiles[0]);
    //std::cout << "D (destination simplex) matrix, determined from first set of global landmarks:\n" << D << std::endl;

    // Now get 'A' matrices from datafiles[1] and up
    for (size_t di = 1; di < datafiles.size(); ++di) {
        morph::TransformMatrix<float> A = readGlobalMatrix (datafiles[di]);
        //std::cout << "A" << di << " =\n" << A << std::endl;
        morph::TransformMatrix<float> Ainv = A.invert();
        //std::cout << "inv(A" << di << "):\n" << Ainv << std::endl;
        // Can now compute trans_mats (named M in my octave code)
        trans_mats[di] = D * Ainv;
        //std::cout << "M["<<di<<"]:\n" << trans_mats[di] << std::endl;
    }
}

//! Add just the landmarks (and global landmarks) in the datafile
//! M: the transform matrix
int addLandmarks (SFVisual& v, const string& datafile, const CmdOptions& co,
                  const morph::TransformMatrix<float>& M, int number)
{
    int rtn = 0;

    bool align_lm = co.use_autoalign > 0 ? false : true;

    try {
        morph::Vector<float> offset = { 0.0, 0.0, 0.0 };

        morph::Scale<float> scale;
        scale.setParams (1.0, 0.0);
        float xx = 0.0f;

        vector<morph::Vector<float>> landmarks_autoaligned;
        vector<morph::Vector<float>> landmarks_lmaligned;

        // Global landmarks
        vector<morph::Vector<float>> globlm_autoaligned;
        vector<morph::Vector<float>> globlm_lmaligned;
        vector<float> glm_id;

        vector<float> landmarks_id;

        {
            morph::HdfData d(datafile, true); // true for read
            int nf = 0;
            d.read_val ("/nframes", nf);

            // Check first frame for alignments
            bool lmalignComputed = false;
            d.read_val ("/Frame001/lmalign/computed", lmalignComputed);
            bool autoalignComputed = false;
            d.read_val ("/Frame001/autoalign/computed", autoalignComputed);

            string frameName("");
            for (int i = 1; i<=nf; ++i) {

                stringstream ss;
                ss << "/Frame";
                ss.width(3);
                ss.fill('0');
                ss << i;
                frameName = ss.str();

                // x position comes from FrameNNN/class/layer_x
                string str = frameName+"/class/layer_x";
                d.read_val (str.c_str(), xx);

                // Landmarks
                vector<array<float, 3>> LM_autoaligned;
                vector<array<float, 3>> LM_lmaligned;
                str = frameName+"/autoalign/landmarks";
                d.read_contained_vals (str.c_str(), LM_autoaligned);
                str = frameName+"/lmalign/landmarks";
                d.read_contained_vals (str.c_str(), LM_lmaligned);
                size_t lmcount = 0;
                float lmid = 0.0f;
                float lmidmax = (float)LM_autoaligned.size();
                for (auto lm : LM_autoaligned) {
                    // TransformMatrix can post multiply by a 3-vector, returning a 4-vector:
                    morph::Vector<float, 4> _lm = M * morph::Vector<float, 3>({lm[0],lm[1],lm[2]});
                    landmarks_autoaligned.push_back ({_lm[0], _lm[1], _lm[2]});
                    lmid = (float)lmcount++ / lmidmax;
                    landmarks_id.push_back (lmid);
                }
                //! convert from vector<array> to vector<Vector> transforming as we go
                for (auto lm : LM_lmaligned) {
                    morph::Vector<float, 4> _lm = M * morph::Vector<float, 3>({lm[0],lm[1],lm[2]});
                    landmarks_lmaligned.push_back ({_lm[0], _lm[1], _lm[2]});
                }
            }

            // Now process global landmarks
            std::vector<std::pair<unsigned int, unsigned int>> glm_table;
            d.read_contained_vals ("/global_landmarks", glm_table);
            for (auto glm : glm_table) {
                std::cout << "Frame: " << glm.first << ", index: " << glm.second << std::endl;
                stringstream ss;
                ss << "/Frame";
                ss.width(3);
                ss.fill('0');
                if (lmalignComputed == true && align_lm == true) {
                    ss << glm.first << "/lmalign/global_landmarks";
                } else {
                    ss << glm.first << "/autoalign/global_landmarks";
                }
                frameName = ss.str();
                vector<array<float, 3>> GLM;
                std::cout << "Reading global landmark in " << frameName << std::endl;
                d.read_contained_vals (frameName.c_str(), GLM);
                std::cout << "GLM size: " << GLM.size() << std::endl;
                for (auto glm : GLM) {
                    morph::Vector<float, 4> _glm = M * morph::Vector<float, 3>({glm[0],glm[1],glm[2]});
                    if (lmalignComputed == true && align_lm == true) {
                        globlm_lmaligned.push_back ({_glm[0], _glm[1], _glm[2]});
                    } else {
                        globlm_autoaligned.push_back ({_glm[0], _glm[1], _glm[2]});
                    }
                    glm_id.push_back (0.3f/number);
                }
            }

            unsigned int visId = 0;

            offset[0]=0.0;

            // Show landmark aligned for preference:
            if (lmalignComputed == true && align_lm == true) {
                // Show the landmarks with a ScatterVisual
                visId = v.addVisualModel (new morph::ScatterVisual<float> (v.shaderprog,
                                                                           &landmarks_lmaligned, offset,
                                                                           &landmarks_id, 0.07f, scale,
                                                                           morph::ColourMapType::Plasma));
                v.landmarks.push_back (visId);

                std::cout << "Showing LM aligned global landmarks...\n";
                for (auto ii : globlm_lmaligned) { std::cout << ii << std::endl; }
                std::cout << "glm_id:\n";
                for (auto ii : glm_id) { std::cout << ii << std::endl; }
                visId = v.addVisualModel (new morph::ScatterVisual<float> (v.shaderprog,
                                                                           &globlm_lmaligned, offset,
                                                                           &glm_id, 0.1f, scale,
                                                                           morph::ColourMapType::Jet));
                v.landmarks.push_back (visId);
            } else {
                visId = v.addVisualModel (new morph::ScatterVisual<float> (v.shaderprog,
                                                                           &landmarks_autoaligned, offset,
                                                                           &landmarks_id, 0.07f, scale,
                                                                           morph::ColourMapType::Plasma));
                v.landmarks.push_back (visId);

                std::cout << "Showing auto aligned global landmarks...\n";
                visId = v.addVisualModel (new morph::ScatterVisual<float> (v.shaderprog,
                                                                           &globlm_autoaligned, offset,
                                                                           &glm_id, 0.1f*number, scale,
                                                                           morph::ColourMapType::Plasma));
                v.landmarks.push_back (visId);
           }
        }
    } catch (const exception& e) {
        cerr << "Caught exception: " << e.what() << endl;
        rtn = -1;
    }

    return rtn;
}

//! Add a visual model for the expression surface, created from the file datafile, to the scene v
int addVisMod (SFVisual& v, const string& datafile, const CmdOptions& co, const float hue,
               morph::TransformMatrix<float>& M)
{
    int rtn = 0;

    bool autoscale_per_slice = co.scale_perslice > 0 ? true : false;
    bool align_lm = co.use_autoalign > 0 ? false : true;
    bool showribbons = co.show_ribbons > 0 ? true : false;
    bool showmesh = co.show_mesh > 0 ? true : false;
    bool showcolour = co.hide_colour > 0 ? false : true;
    float colour_sat = showcolour ? 1.0f : 0.0f;
    std::cout << "colour_sat = " << colour_sat << std::endl;
    morph::ColourMapType cmt = morph::ColourMapType::Monochrome;
    if (showcolour == false) { cmt = morph::ColourMapType::Fixed; }

    try {
        morph::Vector<float> offset = { 0.0, 0.0, 0.0 };

        morph::Scale<float> scale;
        scale.setParams (1.0, 0.0);

        float thickness = 0.0f;
        float xx = 0.0f;

        vector<array<float, 12>> quads_autoaligned; // Get from HDF5
        vector<array<float, 12>> quads_lmaligned;
        vector<array<float, 12>> quads_scaled;
        vector<morph::Vector<float>> points_autoaligned; // Centres of boxes; for smooth surface (points rows)
        vector<morph::Vector<float>> points_lmaligned; // Centres of boxes; for smooth surface (points rows)
        vector<morph::Vector<float>> points_scaled; // Centres of boxes; for smooth surface (points rows)
        vector<float> means;

        vector<morph::Vector<float>> centres_lmaligned;
        vector<morph::Vector<float>> centres_autoaligned;
        vector<morph::Vector<float>> AM_origins_lmaligned;
        vector<morph::Vector<float>> AM_origins_autoaligned;
        vector<float> centres_id;

        {
            cout << "addVisMod: Opening H5 file " << datafile << endl;
            morph::HdfData d(datafile, true); // true for read
            d.read_error_action = morph::ReadErrorAction::Exception;
            int nf = 0;
            d.read_val ("/nframes", nf);

            // Check first frame for alignments
            bool lmalignComputed = false;
            d.read_val ("/Frame001/lmalign/computed", lmalignComputed);
            bool autoalignComputed = false;
            d.read_val ("/Frame001/autoalign/computed", autoalignComputed);

            string frameName("");
            for (int i = 1; i<=nf; ++i) {

                stringstream ss;
                ss << "/Frame";
                ss.width(3);
                ss.fill('0');
                ss << i;
                frameName = ss.str();

                // x position comes from FrameNNN/class/layer_x
                string str = frameName+"/class/layer_x";
                d.read_val (str.c_str(), xx);
                str = frameName+"/class/thickness";
                d.read_val (str.c_str(), thickness);

                // Centres. Get the index into the fitted_lmaligned, to get y/z coordinates of centre locations
                str = frameName+"/lmalign/centre_box_index";
                int clm_idx = 0;
                d.read_val (str.c_str(), clm_idx);

                str = frameName+"/autoalign/centre_box_index";
                int caa_idx = 0;
                d.read_val (str.c_str(), caa_idx);

                std::vector<cv::Point2d> fitted_lmaligned;
                str = frameName+"/lmalign/fitted";
                d.read_contained_vals (str.c_str(), fitted_lmaligned);

                std::vector<cv::Point2d> fitted_autoaligned;
                str = frameName+"/autoalign/fitted";
                d.read_contained_vals (str.c_str(), fitted_autoaligned);

                morph::Vector<float> cp;
                cp[0] = xx;
                cp[1] = fitted_lmaligned[clm_idx].x;
                cp[2] = fitted_lmaligned[clm_idx].y;
                morph::Vector<float, 4> _cp = M * cp;
                centres_lmaligned.push_back ({_cp[0], _cp[1], _cp[2]});

                cp[1] = fitted_autoaligned[caa_idx].x;
                cp[2] = fitted_autoaligned[caa_idx].y;
                _cp = M * cp;
                centres_autoaligned.push_back ({_cp[0], _cp[1], _cp[2]});
                centres_id.push_back (0.1f*(float)i);

                // axis alignment marks are optional, and the data may not exist in the h5 file.
                try {
                    std::vector<cv::Point2d> AM_lmaligned;
                    str = frameName+"/lmalign/alignmark_origins";
                    d.read_contained_vals (str.c_str(), AM_lmaligned);
                    cp[1] = AM_lmaligned[0].x;
                    cp[2] = AM_lmaligned[0].y;
                     _cp = M * cp;
                    AM_origins_lmaligned.push_back ({_cp[0], _cp[1], _cp[2]});
                } catch (const exception& ee) {
                    // Ignore missing AM_origins
                    //std::cout << "Missing alignmark_origins: " << ee.what() << std::endl;
                }

                // axis alignment marks are optional, and the data may not exist in the h5 file.
                try {
                    std::vector<cv::Point2d> AM_autoaligned;
                    str = frameName+"/autoalign/alignmark_origins";
                    d.read_contained_vals (str.c_str(), AM_autoaligned);
                    cp[1] = AM_autoaligned[0].x;
                    cp[2] = AM_autoaligned[0].y;
                    _cp = M * cp;
                    AM_origins_autoaligned.push_back ({_cp[0], _cp[1], _cp[2]});
                } catch (const exception& ee) {
                    // Ignore missing AM_origins
                    //std::cout << "Missing alignmark_origins: " << ee.what() << std::endl;
                }

                vector<array<float, 12>> frameQuads_scaled;
                vector<array<float, 12>> frameQuads_lmaligned;
                vector<array<float, 12>> frameQuads_autoaligned;

                vector<morph::Vector<float>> framePoints_autoaligned;
                vector<morph::Vector<float>> framePoints_lmaligned;
                vector<morph::Vector<float>> framePoints_scaled;

                // Read quads and data for each frame and add to an overall pair of vectors...
                str = frameName+"/autoalign/sboxes";
                d.read_contained_vals (str.c_str(), frameQuads_autoaligned);
                str = frameName+"/lmalign/sboxes";
                d.read_contained_vals (str.c_str(), frameQuads_lmaligned);
                // Un-transformed:
                str = frameName+"/scaled/sboxes";
                d.read_contained_vals (str.c_str(), frameQuads_scaled);

                for (auto fq : frameQuads_autoaligned) {
                    // FIXME: Use centre of box, or even each end of box, or something
                    morph::Vector<float> pt = {fq[0],fq[1],fq[2]};
                    morph::Vector<float, 4> _pt = M * pt;
                    framePoints_autoaligned.push_back ({_pt[0], _pt[1], _pt[2]});
                }

                for (auto fq : frameQuads_lmaligned) {
                    morph::Vector<float, 4> pt = {fq[0], fq[1], fq[2], 1};
                    morph::Vector<float, 4> _pt = M * pt;
                    //std::cout << morph::Vector<float>({fq[0],fq[1],fq[2]}) << " transforms to " << _pt << std::endl;
                    framePoints_lmaligned.push_back ({_pt[0], _pt[1], _pt[2]});
                }

                for (auto fq : frameQuads_scaled) {
                    morph::Vector<float> pt = {fq[0],fq[1],fq[2]};
                    morph::Vector<float, 4> _pt = M * pt;
                    framePoints_scaled.push_back ({_pt[0], _pt[1], _pt[2]});
                }

                vector<double> frameMeans;
                if (autoscale_per_slice) {
                    // Use the auto-scaled version of the means, with each slice autoscaled to [0,1]
                    str = frameName+"/signal/postproc/boxes/means_autoscaled";
                    d.read_contained_vals (str.c_str(), frameMeans);
                } else {
                    // Use the raw means and autoscale them as an entire group
                    str = frameName+"/signal/postproc/boxes/means";
                    d.read_contained_vals (str.c_str(), frameMeans);
                    // The morph::Scale object scale with autoscale the who thing.
                    scale.do_autoscale = true;
                }

                // Gah, convert frameMeans to float (there's a better way to do this)
                vector<float> frameMeansF;
                for (unsigned int j = 0; j < frameMeans.size(); ++j) {
                    frameMeansF.push_back (static_cast<float>(frameMeans[j]));
                }

                quads_autoaligned.insert (quads_autoaligned.end(), frameQuads_autoaligned.begin(), frameQuads_autoaligned.end());
                quads_lmaligned.insert (quads_lmaligned.end(), frameQuads_lmaligned.begin(), frameQuads_lmaligned.end());
                quads_scaled.insert (quads_scaled.end(), frameQuads_scaled.begin(), frameQuads_scaled.end());
                means.insert (means.end(), frameMeansF.begin(), frameMeansF.end());

                points_lmaligned.insert (points_lmaligned.end(), framePoints_lmaligned.begin(), framePoints_lmaligned.end());
                points_autoaligned.insert (points_autoaligned.end(), framePoints_autoaligned.begin(), framePoints_autoaligned.end());
                points_scaled.insert (points_scaled.end(), framePoints_scaled.begin(), framePoints_scaled.end());
            }
            unsigned int visId = 0;

            offset[0]=0.0;

            // Show landmark aligned for preference:
            if (lmalignComputed == true && align_lm == true) {
                if (showribbons) {
                    if (showmesh) {
                        std::cout << "Adding QuadsMeshVisual with hue=" << hue << std::endl;
                        visId = v.addVisualModel (new morph::QuadsMeshVisual<float> (v.shaderprog,
                                                                                     &quads_lmaligned, offset,
                                                                                     &means, scale,
                                                                                     cmt, hue, colour_sat, 0.005f
                                                      ));
                    } else {
                        std::cout << "Adding QuadsVisual with hue=" << hue << std::endl;
                        visId = v.addVisualModel (new morph::QuadsVisual<float> (v.shaderprog,
                                                                                 &quads_lmaligned, offset,
                                                                                 &means, scale,
                                                                                 cmt, hue));

                    }
                } else {
                    // Want to be able to pass colour==off to these. That means ability to pass sat as well as hue.
                    if (showmesh) {
                        std::cout << "Adding pointRowsMeshVisual with hue=" << hue << std::endl;
                        // hue: 1/6 for yellow. 130/360 for a green. 0 for read
                        visId = v.addVisualModel (new morph::PointRowsMeshVisual<float> (v.shaderprog,
                                                                                         &points_lmaligned, offset,
                                                                                         &means, scale,
                                                                                         cmt, hue, colour_sat, 0.9f, 0.005f,
                                                                                         cmt, (0.0/360.0f), 1.0f, 1.0f, 0.015f));
                    } else {
                        std::cout << "Adding PointRowsVisual with hue=" << hue << std::endl;
                        visId = v.addVisualModel (new morph::PointRowsVisual<float> (v.shaderprog,
                                                                                     &points_lmaligned, offset,
                                                                                     &means, scale,
                                                                                     cmt, hue));
                    }
                }
                v.surfaces_3d.push_back (visId);

                visId = v.addVisualModel (new morph::ScatterVisual<float> (v.shaderprog,
                                                                           &centres_lmaligned, offset,
                                                                           &centres_id, 0.03f, scale,
                                                                           morph::ColourMapType::Jet));
                v.angle_centres.push_back (visId);

                if (!AM_origins_lmaligned.empty()) {
                    size_t amo_last = AM_origins_lmaligned.size()-1;
                    std::array<float, 3> rcol = {1.0f,1.0f,1.0f};
                    visId = v.addVisualModel (new morph::RodVisual (v.shaderprog, offset,
                                                                    AM_origins_lmaligned[0], AM_origins_lmaligned[amo_last],
                                                                    0.05f, rcol));
                    v.axes.push_back (visId);
                }

            } else {

                if (showribbons) {
                    visId = v.addVisualModel (new morph::QuadsMeshVisual<float> (v.shaderprog,
                                                                                 &quads_autoaligned, offset,
                                                                                 &means, scale,
                                                                                 cmt, hue, 0.005f));
                } else {
                    visId = v.addVisualModel (new morph::PointRowsVisual<float> (v.shaderprog,
                                                                                 &points_autoaligned, offset,
                                                                                 &means, scale,
                                                                                 cmt, hue));
                }
                v.surfaces_3d.push_back (visId);

                std::cout << "SV6\n";
                visId = v.addVisualModel (new morph::ScatterVisual<float> (v.shaderprog,
                                                                           &centres_autoaligned, offset,
                                                                           &centres_id, 0.03f, scale,
                                                                           morph::ColourMapType::Jet));
                v.angle_centres.push_back (visId);

                if (!AM_origins_autoaligned.empty()) {
                    size_t amo_last = AM_origins_autoaligned.size()-1;
                    std::array<float, 3> rcol = {1.0f,1.0f,1.0f};
                    visId = v.addVisualModel (new morph::RodVisual (v.shaderprog, offset,
                                                                    AM_origins_autoaligned[0], AM_origins_autoaligned[amo_last],
                                                                    0.05f, rcol));
                    v.axes.push_back (visId);
                }
            }
        }
    } catch (const exception& e) {
        cerr << "Caught exception: " << e.what() << endl;
        rtn = -1;
    }

    return rtn;
}

//! Read 3 global landmark positions and place them in a 3x3 matrix.
morph::Matrix33<float> readGlobalPositions (const std::string& datafile,
                                            std::array<unsigned int, 3>& frame_indices)
{
    morph::Matrix33<float> P;
    morph::HdfData d(datafile, true); // true for read
    int nf = 0;
    d.read_val ("/nframes", nf);

    // Check first frame for alignments
    bool lmalignComputed = false;
    d.read_val ("/Frame001/lmalign/computed", lmalignComputed);
    bool autoalignComputed = false;
    d.read_val ("/Frame001/autoalign/computed", autoalignComputed);
    string frameName("");

    // Get global landmarks
    std::vector<std::pair<unsigned int, unsigned int>> glm_table;
    d.read_contained_vals ("/global_landmarks", glm_table);
    vector<array<float, 3>> allGLM;
    size_t i = 0;
    for (auto glmt : glm_table) {
        std::cout << "Frame: " << glmt.first << ", index: " << glmt.second << std::endl;
        frame_indices[i++] = glmt.first;
        stringstream ss;
        ss << "/Frame";
        ss.width(3);
        ss.fill('0');
        if (lmalignComputed == true) {
            ss << glmt.first << "/lmalign/global_landmarks";
        } else {
            ss << glmt.first << "/autoalign/global_landmarks";
        }
        frameName = ss.str();
        vector<array<float, 3>> GLM;
        std::cout << "Reading global landmark in " << frameName << std::endl;
        d.read_contained_vals(frameName.c_str(), GLM);
        std::cout << "GLM has size " << GLM.size() << std::endl;
        std::cout << "Accessing GLM[" << glmt.second-1 << "]\n";
        allGLM.push_back (GLM[glmt.second]);
    }
    if (allGLM.size() < 3) {
        std::cerr << "Need at least 3 global landmarks.\n";
        return P;
    }

    // Can loop through first 3 entries in GLM
    for (size_t i = 0; i < 3; ++i) {
        size_t start = i*3;
        for (size_t j = 0; j<3; ++j) {
            P[start+j] = allGLM[i][j];
        }
    }

    return P;
}

//! Take 3 coordinates in the 3x3 matrix P and convert these into 2D coordinates in the
//! flattened brain plane. Return a 3x3 matrix containing these 2D coords in a form
//! suitable for transformation by a 3x3 transform matrix.
//! datafile: which h5 file are we working with?
//! co: The command options.
//! P: The global landmark Positions as a 3x3 matrix
//! frame_indices: The indices into the frames at which the Global landmarks are to be
//! found. Assumed to be only 1 per slice.
morph::Matrix33<float> convertTwoDims (const string& datafile,
                                       const CmdOptions& co,
                                       const morph::Matrix33<float>& P,
                                       const std::array<unsigned int, 3>& frame_indices)
{
    morph::HdfData d(datafile, true); // true for read
    d.read_error_action = morph::ReadErrorAction::Exception;

    bool lmalignComputed = false;
    d.read_val ("/Frame001/lmalign/computed", lmalignComputed);
    bool autoalignComputed = false;
    d.read_val ("/Frame001/autoalign/computed", autoalignComputed);
    bool align_lm = co.use_autoalign > 0 ? false : true;

    float xx = 0.0f;
    string frameName("");
    string str("");
    morph::Matrix33<float> A; // for return
    for (size_t fi = 0; fi < 3; ++fi) {

        stringstream ss;
        ss << "/Frame";
        ss.width(3);
        ss.fill('0');
        ss << frame_indices[fi];
        frameName = ss.str();

        // x position comes from the frame
        string str = frameName+"/class/layer_x";
        d.read_val (str.c_str(), xx);

        // y position comes from a look at which of framePoints is closest to P.col(i)
        A[fi*3] = xx;

        morph::Vector<float, 3> gl = P.col(fi);
        float mindist = 1e9;

        vector<array<float, 12>> frameQuads_scaled;
        vector<array<float, 12>> frameQuads_lmaligned;
        vector<array<float, 12>> frameQuads_autoaligned;

        vector<morph::Vector<float>> framePoints_autoaligned;
        vector<morph::Vector<float>> framePoints_lmaligned;
        vector<morph::Vector<float>> framePoints_scaled;

        // Read quads and data for each frame and add to an overall pair of vectors...
        str = frameName+"/autoalign/sboxes";
        d.read_contained_vals (str.c_str(), frameQuads_autoaligned);
        str = frameName+"/lmalign/sboxes";
        d.read_contained_vals (str.c_str(), frameQuads_lmaligned);
        // Un-transformed:
        str = frameName+"/scaled/sboxes";
        d.read_contained_vals (str.c_str(), frameQuads_scaled);

        morph::Vector<float, 3> pt;
        size_t ii = 0;
        size_t min_idx = 0;
        if (co.flattened_type == 1) {
            // linear distance boxes
            ii = 0;
            for (auto fq : frameQuads_scaled) {
                pt = {fq[0],fq[1],fq[2]};
                float dist = (pt-gl).length();
                if (dist < mindist) {
                    mindist = dist;
                    min_idx = ii;
                }
                ++ii;
            }
        } else if (co.flattened_type == 2) {
            // angle based boxes
            throw std::runtime_error ("writeme");
        } else {
            // linear distance based on 0 angle starting point:
            if (lmalignComputed == true && align_lm == true) {
                // landmark aligned
                for (auto fq : frameQuads_lmaligned) {
                    morph::Vector<float, 3> pt = {fq[0],fq[1],fq[2]};
                    float dist = (pt-gl).length();
                    if (dist < mindist) {
                        mindist = dist;
                        min_idx = ii;
                    }
                    ++ii;

                }
            } else {
                // auto-aligned
                for (auto fq : frameQuads_autoaligned) {
                    // FIXME: Use centre of box, or even each end of box, or something
                    morph::Vector<float, 3> pt = {fq[0],fq[1],fq[2]};
                    float dist = (pt-gl).length();
                    if (dist < mindist) {
                        mindist = dist;
                        min_idx = ii;
                    }
                    ++ii;
                }
            }
        }
        std::cout << "Index of the quad that's closest to the global landmark: " << min_idx << std::endl;

        // Can now use min_idx to access the 'y' that we'll return in the matrix.
        vector<float> linbins;
        if (co.flattened_type == 1) {
            // linear distance boxes:
            str = frameName+"/scaled/flattened/sbox_linear_distance";
        } else if (co.flattened_type == 2) {
            // angle based boxes:
            str = frameName+"/lmalign/flattened/sbox_angles";
        } else {
            // linear distance based on 0 angle starting point:
            if (lmalignComputed == true && align_lm == true) {
                str = frameName+"/lmalign/flattened/sbox_linear_distance";
            } else {
                str = frameName+"/autoalign/flattened/sbox_linear_distance";
            }
        }
        d.read_contained_vals (str.c_str(), linbins);
        float y = linbins[min_idx];
        A[3*fi+1] = y;
        A[3*fi+2] = 1.0f;
    }
    ///////////////
    std::cout << "The matrix A of 2D coords is\n" << A << std::endl;

    return A;
}

void computeFlatTransforms (const CmdOptions& co,
                            vector<morph::Matrix33<float>>& trans_mats)
{
    if (co.datafiles.size() < 2) {
        // nothing to do though ensure trans_mats[0] contains identity, if necessary
        if (co.datafiles.size()==1 && trans_mats.size()==1) { trans_mats[0].setToIdentity(); }
        return;
    }

    if (co.datafiles.size() != trans_mats.size()) {
        std::cerr << "WARNING: datafiles and trans_mats have to have the same size. Returning.\n";
        return;
    }

    trans_mats[0].setToIdentity();

    // now the fun stuff. Get the relevant global landmark vectors
    std::array<unsigned int, 3> frame_indices;
    morph::Matrix33<float> P = readGlobalPositions (co.datafiles[0], frame_indices);
    // How to get frame_indices? With readGlobalPositions i guess.
    morph::Matrix33<float> D = convertTwoDims (co.datafiles[0], co, P, frame_indices);

    // Now get 'A' matrices from datafiles[1] and up
    for (size_t di = 1; di < co.datafiles.size(); ++di) {
        morph::Matrix33<float> P = readGlobalPositions (co.datafiles[di], frame_indices);
        morph::Matrix33<float> A = convertTwoDims (co.datafiles[di], co, P, frame_indices);
        morph::Matrix33<float> Ainv = A.invert();
        trans_mats[di] = D * Ainv;
    }
}

//! Add flattened map
int addFlattened (SFVisual& v, const string& datafile, const CmdOptions& co,
                  morph::Vector<float> offset = { 0.0f, 0.0f, 0.0f })
{
    int rtn = 0;

    bool autoscale_per_slice = co.scale_perslice > 0 ? true : false;
    bool align_lm = co.use_autoalign > 0 ? false : true;

    try {

        morph::Scale<float> scale;
        scale.setParams (1.0, 0.0);

        float thickness = 0.0f;
        float xx = 0.0f;
        vector<array<float, 12>> fquads; // Flat quads, for the flat visualization
        vector<float> means;
        vector<float> fmeans;

        {
            cout << "Opening H5 file " << datafile << endl;
            morph::HdfData d(datafile, true); // true for read
            int nf = 0;
            d.read_val ("/nframes", nf);

            // Check first frame for alignments
            bool lmalignComputed = false;
            d.read_val ("/Frame001/lmalign/computed", lmalignComputed);
            bool autoalignComputed = false;
            d.read_val ("/Frame001/autoalign/computed", autoalignComputed);

            if (co.flattened_type == 1) {
                // linear distance boxes:
                std::cout << "Showing centered, linear distance as y axis for 2D map.\n";
            } else if (co.flattened_type == 2) {
                // angle based boxes:
                std::cout << "Showing angle as y axis for 2D map.\n";
            } else {
                // linear distance based on 0 angle starting point:
                if (lmalignComputed == true && align_lm == true) {
                    std::cout << "Showing linear distance unwrapped from 3D landmark aligned reconstruction as y axis for 2D map.\n";
                } else {
                    std::cout << "Showing linear distance unwrapped from 3D auto-aligned reconstruction as y axis for 2D map.\n";
                }
            }

            string frameName("");
            for (int i = 1; i<=nf; ++i) {

                stringstream ss;
                ss << "/Frame";
                ss.width(3);
                ss.fill('0');
                ss << i;
                frameName = ss.str();

                // x position comes from FrameNNN/class/layer_x
                string str = frameName+"/class/layer_x";
                d.read_val (str.c_str(), xx);
                str = frameName+"/class/thickness";
                d.read_val (str.c_str(), thickness);
                vector<double> frameMeans;
                if (autoscale_per_slice) {
                    // Use the auto-scaled version of the means, with each slice autoscaled to [0,1]
                    str = frameName+"/signal/postproc/boxes/means_autoscaled";
                    d.read_contained_vals (str.c_str(), frameMeans);
                } else {
                    // Use the raw means and autoscale them as an entire group
                    str = frameName+"/signal/postproc/boxes/means";
                    d.read_contained_vals (str.c_str(), frameMeans);
                    // The morph::Scale object scale with autoscale the who thing.
                    scale.do_autoscale = true;
                }

                // Gah, convert frameMeans to float (there's a better way to do this)
                vector<float> frameMeansF;
                for (unsigned int j = 0; j < frameMeans.size(); ++j) {
                    frameMeansF.push_back (static_cast<float>(frameMeans[j]));
                }
                // Load in linear stuff as well, to make up flat boxes? Or easier to do at source?
                vector<float> linbins;
                if (co.flattened_type == 1) {
                    // linear distance boxes:
                    str = frameName+"/scaled/flattened/sbox_linear_distance";
                } else if (co.flattened_type == 2) {
                    // angle based boxes:
                    str = frameName+"/lmalign/flattened/sbox_angles";
                } else {
                    // linear distance based on 0 angle starting point:
                    if (lmalignComputed == true && align_lm == true) {
                        str = frameName+"/lmalign/flattened/sbox_linear_distance";
                    } else {
                        str = frameName+"/autoalign/flattened/sbox_linear_distance";
                    }
                }
                d.read_contained_vals (str.c_str(), linbins);

                // now - if the linbins we loaded were the sbox_angles, then we need to
                // sort linbins, while sorting, at the same time, the signals.

                vector<array<float,12>> flatsurf_boxes;
                array<float, 12> sbox;
                for (unsigned int j = 1; j < linbins.size(); ++j) {
                    // c1 x,y,z
                    sbox[0] = xx-thickness; // x
                    sbox[1] = linbins[j-1]; // y
                    sbox[2] = 0.0;          // z
                    // c2 x,y,z
                    sbox[3] = xx-thickness;
                    sbox[4] = linbins[j];
                    sbox[5] = 0.0;
                    // c3 x,y,z
                    sbox[6] = xx;
                    sbox[7] = linbins[j];
                    sbox[8] = 0.0;
                    // c4 x,y,z
                    sbox[9] = xx;
                    sbox[10] = linbins[j-1];
                    sbox[11] = 0.0;

                    // For angle based view, have to tweak the box angles by +-2pi to avoid boxes that span the whole ribbon.
                    if (co.flattened_type == 2) {
                        if (std::abs(sbox[1] - sbox[4])  > morph::PI_F && std::abs(sbox[7] - sbox[10]) > morph::PI_F) {
                            //std::cout << "PROBLEM BOX\n";
                            if (sbox[4] < 0) {
                                sbox[4] += morph::TWO_PI_F;
                                sbox[7] += morph::TWO_PI_F;
                            } else {
                                sbox[4] -= morph::TWO_PI_F;
                                sbox[7] -= morph::TWO_PI_F;
                            }
                        }
                    }
#if 0 // DEBUG
                    std::cout << "c1: " << sbox[0] << "," << sbox[1] << "," << sbox[2];
                    std::cout << "   c2: " << sbox[3] << "," << sbox[4] << "," << sbox[5];
                    std::cout << "   c3: " << sbox[6] << "," << sbox[7] << "," << sbox[8];
                    std::cout << "   c4: " << sbox[9] << "," << sbox[10] << "," << sbox[11] << std::endl;
#endif
                    flatsurf_boxes.push_back (sbox);
                }
                fquads.insert (fquads.end(), flatsurf_boxes.begin(), flatsurf_boxes.end());
                fmeans.insert (fmeans.end(), frameMeansF.begin(), --frameMeansF.end());
            }
            unsigned int visId = 0;

            // This is the flattened map; showing it alongside the 3D map for now
            offset[0]+=-5.5;
            visId = v.addVisualModel (new morph::QuadsVisual<float> (v.shaderprog,
                                                                     &fquads, offset,
                                                                     &fmeans, scale,
                                                                     morph::ColourMapType::Greyscale));
            v.surfaces_2d.push_back (visId);

            // Add a row of points for the centre marker, for debugging
            vector<morph::Vector<float>> centres_;
            vector<float> centres_id;
            for (int i = 1; i < nf; ++i) {
                stringstream ss;
                ss << "/Frame";
                ss.width(3);
                ss.fill('0');
                ss << i;
                frameName = ss.str();
                string str = frameName+"/class/layer_x";
                d.read_val (str.c_str(), xx);
                morph::Vector<float> cp;
                cp[0] = xx;
                cp[1] = 0;
                cp[2] = 0;
                centres_.push_back (cp);
                centres_id.push_back (0.1f*(float)i);
            }

            visId = v.addVisualModel (new morph::ScatterVisual<float> (v.shaderprog,
                                                                       &centres_, offset,
                                                                       &centres_id, 0.03f, scale,
                                                                       morph::ColourMapType::Jet));
            v.angle_centres.push_back (visId);
        }
    } catch (const exception& e) {
        cerr << "Caught exception: " << e.what() << endl;
        rtn = -1;
    }

    return rtn;
}

int main (int argc, char** argv)
{
    int rtn = -1;

    // popt command line argument processing setup
    zeroCmdOptions (&cmdOptions);

    struct poptOption opt[] = {
        POPT_AUTOHELP

        {"scale_perslice", 'p',
         POPT_ARG_NONE, &(cmdOptions.scale_perslice), 0, // 0 is 'val' which is available in callbacks
         "If set, auto-scale the signal for each slice."},

        {"use_autoalign", 'a',
         POPT_ARG_NONE, &(cmdOptions.use_autoalign), 0,
         "If set, prefer the auto-alignment (based on the curve points only) rather than landscape alignment."},

        {"show_ribbons", 'r',
         POPT_ARG_NONE, &(cmdOptions.show_ribbons), 0,
         "If set, display the ribbon-like surface boxes, rather than the smoothed surface."},

        {"show_mesh", 'e',
         POPT_ARG_NONE, &(cmdOptions.show_mesh), 0,
         "If set, display the mesh version of the surface."},

        {"lighting", 'g',
         POPT_ARG_NONE, &(cmdOptions.lighting), 0,
         "If set, apply ambient/diffuse lighting in the shader."},

        {"hide_colour", 'c',
         POPT_ARG_NONE, &(cmdOptions.hide_colour), 0,
         "If set, hide the colour that indicates the ISH expression data value."},

        {"show_landmarks", 'l',
         POPT_ARG_INT, &(cmdOptions.show_landmarks), 0,
         "Display landmarks from the indexed (counting from 1) data file."},

        {"show_landmarks_all", 'L',
         POPT_ARG_NONE, &(cmdOptions.show_landmarks_all), 0,
         "If set, display landmarks from ALL first data files."},

        {"show_flattened", 'm',
         POPT_ARG_INT, &(cmdOptions.show_flattened), 0,
         "Display flattened image from the data file with this index (counting from 1), to compare with 3D."},

        {"flattened_type", 't',
         POPT_ARG_INT, &(cmdOptions.flattened_type), 0,
         "Selects the type of flattened map to show: 0 (default): use aligned 3D image and compute linear "
         "distance along the curve starting from the surface box that is on the zero degree line wrt the "
         "origin. 1: Use centered surface box linear distance. 2: Plot vs. the angle of the surface box."},

        {"linear_transforms", 'T',
         POPT_ARG_NONE, &(cmdOptions.linear_transforms), 0,
         "If >1 model, then transform each model index > 0 to match model index 0, using global "
         "landmarks of which there should be 4 in each model."},

        // options following this will cause the popt_option_callback to be executed.
        { "callback", '\0',
          POPT_ARG_CALLBACK|POPT_ARGFLAG_DOC_HIDDEN, (void*)&popt_option_callback, 0,
          NULL, NULL },

        {"datafile", 'f',
         POPT_ARG_STRING, &(cmdOptions.datafile), 0,
         "Add a data file to visualise in 3D. Provide an argument like /path/to/file.h5. "
         "This option can be used multiple times, and you can even leave the -f out; any "
         "'non-option' strings on your command line will be interpreted as data files."},

        POPT_AUTOALIAS
        POPT_TABLEEND
    };
    poptContext con;
    con = poptGetContext (argv[0], argc, (const char**)argv, opt, 0);
    while (poptGetNextOpt(con) != -1) {}
    const char* argg = (char*)0;
    while ((argg = poptGetArg(con)) != (char*)0) {
        // Treat any extra args as files.
        //string df(argg);
        cmdOptions.datafiles.push_back (string(argg));
    }

    try {
        if (cmdOptions.datafiles.empty()) {
            throw std::runtime_error ("Please supply at least one HDF5 file with the -f option.");
        }
    } catch (const exception& e) {
        cerr << "Error: " << e.what() << endl;
        rtn = -1;
        poptFreeContext(con);
        return rtn;
    }
    // End processing options. Can now access options via cmdOptions

    // Visual scene for all models
    morph::Vector<float, 2> coordArrowLocn = {-0.75,-0.7};
    morph::Vector<float> coordArrowLengths = {0.14f, 0.07f, 0.07f};
    SFVisual v(2000, 1400, cmdOptions.datafiles[0], coordArrowLocn, coordArrowLengths, 1.0f, 0.01f);
    v.zNear = 0.001;
    v.zFar = 40.0;
    v.showTitle = false;
    v.showCoordArrows = true;
    // Enable lighting if asked for, or automatically for mesh views
    if (cmdOptions.lighting > 0 || cmdOptions.show_mesh > 0) {
        v.lightingEffects (true);
    }
    v.diffuse_position = {-1, 2, -3};

    // Before addVisMod(), addLandmarks(), etc, and if there is more than 1 model and if
    // the "compute linear transformations" option is true, then compute linear
    // transformations that should be applied to each model index > 0.
    vector<morph::TransformMatrix<float>> trans_mats(cmdOptions.datafiles.size());
    if (cmdOptions.linear_transforms > 0 && cmdOptions.datafiles.size() > 1) {
        std::cout << "Applying linear transforms...\n";
        computeTransforms (cmdOptions.datafiles, trans_mats, cmdOptions);
    }

    // For each file in cmdOptions.datafiles:
    // 0 red .2 yellow .3 green .4 cyan green .5 cyan .6 blue .7 blue .8 purple .9 red
    vector<float> hues = {0.0f, 0.7f, 0.8f, 0.1f, 0.5f, 0.6f, 0.1f, 0.8f};
    float hue = 0.0f;
    for (unsigned int ii = 0; ii < cmdOptions.datafiles.size(); ++ii) {
        if (ii < hues.size()) {
            hue = hues[ii];
        } else {
            hue = 0.8f;
        }
        // WRITEME NEXT: Pass trans_mats into addVisMod and apply to the coords therein.
        std::cout << "Calling addVisMod (...,trans_mats["<<ii<<"]\n";
        rtn += addVisMod (v, cmdOptions.datafiles[ii], cmdOptions, hue, trans_mats[ii]);
    }

    // And landmarks
    std::cout << "show_landmarks: " << cmdOptions.show_landmarks << "\n";
    if (cmdOptions.show_landmarks_all) {
        for (unsigned int ii = 0; ii < cmdOptions.datafiles.size(); ++ii) {
            //std::cout << "Add landmarks, multiplying positions by\n" << trans_mats[ii] << std::endl;
            rtn += addLandmarks (v, cmdOptions.datafiles[ii], cmdOptions, trans_mats[ii], 1+ii);
        }
    } else {
        if (cmdOptions.show_landmarks > 0 && static_cast<int>(cmdOptions.datafiles.size()) >= cmdOptions.show_landmarks) {
            unsigned int ii = cmdOptions.show_landmarks-1;
            //std::cout << "Add landmarks (one-off), multiplying positions by\n" << trans_mats[ii] << std::endl;
            rtn += addLandmarks (v, cmdOptions.datafiles[ii], cmdOptions, trans_mats[ii], 1);
        }
    }

    // Add requested flattened map
    std::cout << "show_flattened: " << cmdOptions.show_flattened << "\n";
#if 0
    // Previously I selected a particular map from multiple datafiles to be displayed
    if (cmdOptions.show_flattened > 0 && static_cast<int>(cmdOptions.datafiles.size()) >= cmdOptions.show_flattened) {
        rtn += addFlattened (v, cmdOptions.datafiles[cmdOptions.show_flattened-1], cmdOptions);
    }
#else
    if (cmdOptions.show_flattened > 0) {

        // FIXME: Equivalent of computeTransforms() here? But need global landmarks in 3D first.
        std::cout << "Compute flat transforms...\n";
        std::vector<morph::Matrix33<float>> trans_mats2(cmdOptions.datafiles.size());
        computeFlatTransforms (cmdOptions, trans_mats2);

        float xoffs = 0.0f;
        for (auto df : cmdOptions.datafiles) {
            rtn += addFlattened (v, df, cmdOptions, {xoffs, 0, 0});
            xoffs += -6.0f;
        }
    }
#endif

    try {
        v.render();
        while (v.readyToFinish == false) {
            glfwWaitEventsTimeout (0.018);
            v.render();
        }
    } catch (const exception& e) {
        cerr << "Caught exception: " << e.what() << endl;
        rtn = -1;
    }

    poptFreeContext(con);
    return rtn;
}
